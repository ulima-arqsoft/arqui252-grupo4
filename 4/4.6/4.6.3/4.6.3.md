> [4. Decisiones Iniciales de Arquitectura](../../4.md) ‚Ä∫ [4.6. Listado Consolidado](../4.6.md) ‚Ä∫ [4.6.3. Modelo de Datos](4.6.3.md)

# 4.6.3. Modelo de Datos

Este apartado define la elecci√≥n de las abstracciones de datos, la organizaci√≥n de la persistencia y la estrategia de mapeo para los microservicios de GameVault.

## 00: Decisiones Generales
---
### Decisi√≥n 1: Estrategia de Persistencia por M√≥dulo

**T√≠tulo:**
Elecci√≥n del Modelo de Persistencia (Pol√≠glota) Basado en las Necesidades del M√≥dulo

**Contexto:**
Dado que GameVault utiliza una arquitectura de microservicios, cada m√≥dulo tiene responsabilidades de datos fundamentalmente diferentes.

* **Cat√°logo de Productos (CP):** Datos masivos, est√°ticos, con alta necesidad de b√∫squeda y filtrado complejos.
* **Carrito y Pedidos (CCP):** Datos transaccionales, relacionales, que requieren alta integridad (**ACID**).
* **Comunidad y Rese√±as (CR):** Datos semiestructurados (texto de rese√±as, comentarios) y alta concurrencia de escritura

**Alternativas:**

* **Persistencia Homog√©nea (Solo SQL):** Usar una √∫nica tecnolog√≠a relacional (ej. PostgreSQL) para todos los m√≥dulos. Ofrece consistencia y familiaridad, pero es ineficiente para b√∫squedas de texto y anal√≠tica.
* **Persistencia Pol√≠glota:** Usar la tecnolog√≠a de base de datos m√°s adecuada para cada microservicio. Ofrece rendimiento y escalabilidad √≥ptimos por dominio.

**Criterios de Elecci√≥n:**

* **Optimizaci√≥n de Rendimiento:** Usar el motor adecuado para la carga de trabajo (transaccional vs. b√∫squeda).
* **Escalabilidad:** Permitir que los datos masivos del Cat√°logo y los transaccionales escalen de forma independiente.
* **Integridad de Datos:** Garantizar la consistencia en los m√≥dulos de venta (CCP y SP).

**Decisi√≥n:**
Se adopta una estrategia de **Persistencia Pol√≠glota**, seleccionando modelos de bases de datos diferentes seg√∫n la responsabilidad de cada m√≥dulo.

**Sustento:**
El enfoque pol√≠glota es indispensable en microservicios, ya que optimiza el **Rendimiento** y la **Escalabilidad**. Se utilizar√° un modelo de datos **relacional (SQL)** para asegurar la **Integridad** en flujos cr√≠ticos (Pedidos, Usuarios) y modelos **NoSQL/Motores de B√∫squeda** para datos de alta velocidad o masividad (Cat√°logo, Rese√±as).

## 01: M√≥dulo: Cat√°logo de Productos
---
### Decisi√≥n 1: Organizaci√≥n del Modelo de Datos para Metadatos y B√∫squeda

**T√≠tulo:**
Organizaci√≥n y Abstracci√≥n de Datos para el Cat√°logo de Productos

**Contexto:**
El Cat√°logo debe almacenar millones de metadatos de juegos (t√≠tulo, descripci√≥n, g√©nero, consola, rareza, condici√≥n). Los datos est√°n altamente interconectados (un juego tiene muchos g√©neros y plataformas), y la b√∫squeda es el requisito de acceso principal.

**Alternativas:**

* **Modelo Relacional Estricto (Normalizado):** Tablas separadas para Juegos, Consolas, G√©neros. Garantiza la integridad, pero las consultas de b√∫squeda y los *JOINs* son lentos.
* **Modelo Documental (Desnormalizado):** Almacenar toda la informaci√≥n de un juego como un √∫nico documento JSON. Optimiza la lectura y permite una ingesti√≥n flexible de metadatos.
* **√çndice de B√∫squeda (Texto Completo):** Utilizar un √≠ndice dedicado (ej. Elasticsearch) que almacene una versi√≥n optimizada de los documentos para b√∫squeda y filtrado.

**Criterios de Elecci√≥n:**

* **Velocidad de Lectura/B√∫squeda:** M√°xima velocidad para consultas de frontend.
* **Flexibilidad de Esquema:** Facilidad para a√±adir nuevos atributos de juegos (ej. nuevas etiquetas o propiedades de condici√≥n).
* **Mapeo de Datos:** Necesidad de un mapeo simple para pasar datos de la BD maestra al motor de b√∫squeda.

**Decisi√≥n:**
Combinaci√≥n de **Base de Datos Documental (MongoDB/Firestore)** como fuente maestra y un **Motor de B√∫squeda (Elasticsearch)** como capa de acceso r√°pido.

**Sustento:**
El modelo **Documental** ofrece **Flexibilidad de Esquema** para metadatos variados. El motor de B√∫squeda garantiza la **Velocidad de Lectura/B√∫squeda** ultrarr√°pida (Decisi√≥n 4.6.1.02.1). La abstracci√≥n principal de datos ser√° el objeto *"Product Listing"* (Juego en venta) que contiene todos los metadatos relevantes para la b√∫squeda y visualizaci√≥n.

## 02: M√≥dulo: Gesti√≥n de Usuarios
---
### Decisi√≥n 1: Modelo de Datos para Perfiles, Roles y Autorizaci√≥n.

**T√≠tulo:**
Estructura de Datos para Perfiles, Roles y Seguridad

**Contexto:**
El M√≥dulo GU almacena informaci√≥n sensible y cr√≠tica: perfiles de usuario, roles (Comprador/Vendedor) e historial de transacciones. Se necesita un modelo de datos que garantice la integridad, la seguridad y la facilidad para realizar *joins* con datos transaccionales (Pedidos).

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ofrece transacciones ACID, integridad referencial y modelado natural para entidades interconectadas (Usuario $\rightarrow$ Roles $\rightarrow$ Historial).
* **Base de Datos de Gr√°fos (Neo4j):** Ideal para modelar relaciones sociales y permisos complejos, pero excesivo para un perfil de usuario simple.

**Criterios de Elecci√≥n:**

* **Integridad y Relaciones:** Necesidad de garantizar la validez de los roles y el mapeo al historial de transacciones.
* **Seguridad:** El entorno SQL es maduro y ofrece buenas herramientas de seguridad a nivel de fila y columna.
* **Consultas de Acceso:** Consultas directas basadas en ID de usuario y *joins* simples para obtener el historial.

**Decisi√≥n:**
**Base de Datos Relacional (SQL)** para almacenar la entidad *User* (Perfil, Roles, Historial B√°sico).

**Sustento:**
El modelo **Relacional** es el est√°ndar para datos de identidad y perfiles debido a su **Integridad** y las garant√≠as **ACID**. Permite consultas eficientes y seguras para verificar el rol del usuario durante la autorizaci√≥n en otros microservicios.

## 03: M√≥dulo: Carrito de Compras y Pedidos
---
### Decisi√≥n 1: Modelo de Datos para Pedidos y Garant√≠a de Integridad.

**T√≠tulo:**
Elecci√≥n del Modelo de Datos para Transacciones Cr√≠ticas

**Contexto:**
El M√≥dulo CCP gestiona el carrito (temporal) y la creaci√≥n de pedidos (persistente). Esta es la funcionalidad m√°s cr√≠tica, requiriendo que los datos sean coherentes, at√≥micos y altamente confiables. Se deben registrar √≠tems, precios unitarios fijos y totales finales.

**Alternativas:**

* **Base de Datos NoSQL (ej. MongoDB):** R√°pida y flexible, pero carece de garant√≠as ACID robustas y transacciones distribuidas complejas (a menos que se implementen manualmente).
* **Base de Datos Relacional (SQL):** Ofrece transacciones **ACID** nativas, integridad referencial y esquemas bien definidos, ideales para flujos financieros.
**Criterios de Elecci√≥n:**

* **Integridad Transaccional:** Necesidad de transacciones **ACID** para crear un pedido.
* **Consistencia:** Las referencias al usuario, art√≠culos y pagos deben ser consistentes.
* **Estructura:** El objeto "Pedido" tiene una estructura inherentemente relacional (Pedido $\rightarrow$ √çtems).

**Decisi√≥n:**
Base de Datos Relacional (SQL) para Pedidos y Carrito Persistente.

**Sustento:**
La **Integridad Transaccional** es un requisito innegociable para la gesti√≥n de Pedidos. El modelo **Relacional** garantiza que la creaci√≥n del Pedido (reservar inventario y registrar detalles financieros) sea at√≥mica y coherente, lo cual es fundamental para el m√≥dulo de comercio electr√≥nico.

## 04: M√≥dulo: Sistema de Pagos
---
### Decisi√≥n 1: Modelo de Datos para el Registro de Transacciones y Sincronizaci√≥n de Pasarelas.

**T√≠tulo:**
Abstracci√≥n de Datos para el Registro de Transacciones Financieras

**Contexto:**
El M√≥dulo SP solo almacena el registro de la transacci√≥n (ID del pedido, monto, ID de la pasarela, estado, *token* de pago si aplica) sin custodiar datos sensibles de tarjeta. Este registro debe ser inmutable y auditable.

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ideal para registros financieros por su estricto esquema y transacciones at√≥micas.
* **Base de Datos Orientada a Eventos (Event Store):** Almacena el historial de pagos como una secuencia inmutable de eventos.

**Criterios de Elecci√≥n:**

* **Auditor√≠a e Inmutabilidad:** El registro de un pago no debe ser alterable una vez completado.
* **Simplicidad de Consulta:** Consulta simple para verificar el estado de un pago.
* **Integridad con Pedido:** Necesidad de una referencia estricta al ID del Pedido de CCP.

**Decisi√≥n:**
**Base de Datos Relacional (SQL)** para la entidad *Transaction Log* (Registro de Transacci√≥n).

**Sustento:**
Usar **SQL** proporciona el nivel de **Integridad** y **Auditor√≠a** necesario para los datos financieros. La *Transaction Log* ser√° una tabla inmutable que registra el intento de pago, el resultado y la referencia √∫nica de la pasarela de pago, esencial para la reconciliaci√≥n contable.

## 05: M√≥dulo: Log√≠stica y Env√≠os
---
### Decisi√≥n 1: Organizaci√≥n de Metadatos de Transportistas y Rastreo de Pedido.

**T√≠tulo:**
Abstracci√≥n de Datos para Entidades de Log√≠stica y Seguimiento

**Contexto:**
El M√≥dulo LE necesita datos de transportistas (tarifas, tiempos) y debe rastrear el estado de cada pedido a trav√©s de m√∫ltiples pasos (Empaquetado, En Tr√°nsito, Entregado).

**Alternativas:**

* **Modelo de Eventos/Estados (SQL):** Una tabla `TrackingUpdates` donde cada fila es una actualizaci√≥n de estado con marca de tiempo.
* **Modelo Documental Anidado (NoSQL):** Un documento `Shipment` que contiene un *array* anidado de todos los `TrackingEvents`.

**Criterios de Elecci√≥n:**

* **Trazabilidad Temporal:** Facilidad para consultar el historial de estado en orden.
* **Velocidad de Escritura:** Las actualizaciones de estado son frecuentes y r√°pidas.
* **Mapeo:** El objeto `Shipment` es una abstracci√≥n natural para la API de seguimiento.

**Decisi√≥n:**
Base de Datos Relacional (SQL) para el objeto principal *Shipment* con un campo de tipo *array*/JSON para almacenar el historial de eventos (*embedded NoSQL data within SQL*).

**Sustento:**
Usar **SQL** garantiza la **Integridad** del objeto *Shipment* (asociado al Pedido de CCP). Almacenar el historial de eventos de rastreo como un campo JSON o *Array* dentro del registro SQL combina la **Integridad Relacional** con la **Flexibilidad de Escritura** r√°pida del modelo NoSQL para los datos de seguimiento en tiempo real.

## 06: M√≥dulo: Comunidad y Rese√±as
---
### Decisi√≥n 1: Organizaci√≥n del Modelo de Datos para Rese√±as y Contenido No Estructurado.

**T√≠tulo:**
Abstracci√≥n de Datos y Estructura para Rese√±as y Valoraciones

**Contexto:**
El M√≥dulo CR gestiona rese√±as de texto (contenido variable, no estructurado) y valoraciones num√©ricas (1-5 o 1-100). Es crucial poder consultar r√°pidamente la puntuaci√≥n media de un juego y listar las rese√±as m√°s recientes o mejor valoradas.

**Alternativas:**

* **Base de Datos Relacional:** Almacenar rese√±as y valoraciones en tablas. Requiere *JOINs* para calcular el promedio.
* **Base de Datos Documental/Clave-Valor:** Almacenar cada rese√±a como un documento y mantener un contador/promedio pre-calculado.

**Criterios de Elecci√≥n:**

* **Velocidad de Lectura:** Acceso r√°pido a las rese√±as de un producto.
* **Concurrencia de Escritura:** El sistema debe manejar muchas rese√±as/comentarios simult√°neos.
* **Flexibilidad:** El contenido textual (la rese√±a) puede variar en longitud y formato.

**Decisi√≥n:**
Base de Datos Documental (NoSQL, ej. MongoDB) para almacenar la entidad *Review*, y un campo pre-calculado en el M√≥dulo CP para el promedio de valoraci√≥n.

**Sustento:**
El modelo **Documental** es ideal para datos de texto **semiestructurados** y de alta **Concurrencia de Escritura**. Para optimizar la **Velocidad de Lectura**, el **Promedio de Valoraci√≥n** se calcular√° as√≠ncronamente y se enviar√° como metadato al M√≥dulo CP para su visualizaci√≥n inmediata, evitando consultas lentas.

## 07: M√≥dulo: An√°lisis de Datos y Reportes
---
### Decisi√≥n 1: Organizaci√≥n de Datos para Consultas Anal√≠ticas

**T√≠tulo:**
Modelo de Almacenamiento y Organizaci√≥n para la Anal√≠tica de Datos

**Contexto:**
El M√≥dulo ADR requiere realizar consultas complejas sobre grandes vol√∫menes de datos hist√≥ricos (ventas, b√∫squedas, demograf√≠a) para generar reportes y m√©tricas de tendencia, sin afectar los sistemas de producci√≥n.

**Alternativas:**

* **Almacenamiento en Base de Datos Relacional Normalizada:** Ineficiente y lento para consultas de agregaci√≥n a trav√©s de grandes periodos de tiempo.
* **Modelo Dimensional (Data Warehouse):** Organizaci√≥n de datos optimizada para consultas (esquema estrella/copo de nieve), ideal para reportes **OLAP** y agregaci√≥n.
* **Data Lake (Almacenamiento de Archivos Brutos):** Permite el almacenamiento de datos sin procesar, ideal para exploraciones de Machine Learning y an√°lisis futuros.

**Criterios de Elecci√≥n:**

* **Velocidad de Consulta Anal√≠tica:** Optimizar las consultas de agregaci√≥n y filtros complejos.
* **Separaci√≥n de Cargas:** Aislar totalmente la carga de la anal√≠tica de la carga transaccional.
* **Escalabilidad de Almacenamiento:** Manejar petabytes de datos hist√≥ricos de forma rentable.

**Decisi√≥n:**
Combinaci√≥n de **Data Warehouse (Modelo Dimensional)** para reportes estructurados y **Data Lake** para almacenamiento de eventos brutos (eventos de b√∫squeda, clics).

**Sustento:**
La utilizaci√≥n de un **Data Warehouse (Modelo Dimensional)** garantiza la **Velocidad de Consulta Anal√≠tica** para los reportes de ventas y tendencias estructuradas. El **Data Lake** proporciona **Escalabilidad** de almacenamiento y una fuente de datos *raw* para futuros proyectos de *Machine Learning* sobre el comportamiento de b√∫squeda y *churn* de usuarios.

[‚¨ÖÔ∏è Anterior](../4.6.2/4.6.2.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../4.6.4/4.6.4.md)