> [4. Decisiones Iniciales de Arquitectura](../../4.md) › [4.6. Listado Consolidado](../4.6.md) › [4.6.3. Modelo de Datos](4.6.3.md)

# 4.6.3. Modelo de Datos

Este apartado define la elección de las abstracciones de datos, la organización de la persistencia y la estrategia de mapeo para los microservicios de GameVault.

## 00: Decisiones Generales
---
### Decisión 1: Estrategia de Persistencia por Módulo

**Título:**
Elección del Modelo de Persistencia (Políglota) Basado en las Necesidades del Módulo

**Contexto:**
Dado que GameVault utiliza una arquitectura de microservicios, cada módulo tiene responsabilidades de datos fundamentalmente diferentes.

* **Catálogo de Productos (CP):** Datos masivos, estáticos, con alta necesidad de búsqueda y filtrado complejos.
* **Carrito y Pedidos (CCP):** Datos transaccionales, relacionales, que requieren alta integridad (**ACID**).
* **Comunidad y Reseñas (CR):** Datos semiestructurados (texto de reseñas, comentarios) y alta concurrencia de escritura

**Alternativas:**

* **Persistencia Homogénea (Solo SQL):** Usar una única tecnología relacional (ej. PostgreSQL) para todos los módulos. Ofrece consistencia y familiaridad, pero es ineficiente para búsquedas de texto y analítica.
* **Persistencia Políglota:** Usar la tecnología de base de datos más adecuada para cada microservicio. Ofrece rendimiento y escalabilidad óptimos por dominio.

**Criterios de Elección:**

* **Optimización de Rendimiento:** Usar el motor adecuado para la carga de trabajo (transaccional vs. búsqueda).
* **Escalabilidad:** Permitir que los datos masivos del Catálogo y los transaccionales escalen de forma independiente.
* **Integridad de Datos:** Garantizar la consistencia en los módulos de venta (CCP y SP).

**Decisión:**
Se adopta una estrategia de **Persistencia Políglota**, seleccionando modelos de bases de datos diferentes según la responsabilidad de cada módulo.

**Sustento:**
El enfoque políglota es indispensable en microservicios, ya que optimiza el **Rendimiento** y la **Escalabilidad**. Se utilizará un modelo de datos **relacional (SQL)** para asegurar la **Integridad** en flujos críticos (Pedidos, Usuarios) y modelos **NoSQL/Motores de Búsqueda** para datos de alta velocidad o masividad (Catálogo, Reseñas).

## 01: Módulo: Catálogo de Productos
---
### Decisión 1: Organización del Modelo de Datos para Metadatos y Búsqueda

**Título:**
Organización y Abstracción de Datos para el Catálogo de Productos

**Contexto:**
El Catálogo debe almacenar millones de metadatos de juegos (título, descripción, género, consola, rareza, condición). Los datos están altamente interconectados (un juego tiene muchos géneros y plataformas), y la búsqueda es el requisito de acceso principal.

**Alternativas:**

* **Modelo Relacional Estricto (Normalizado):** Tablas separadas para Juegos, Consolas, Géneros. Garantiza la integridad, pero las consultas de búsqueda y los *JOINs* son lentos.
* **Modelo Documental (Desnormalizado):** Almacenar toda la información de un juego como un único documento JSON. Optimiza la lectura y permite una ingestión flexible de metadatos.
* **Índice de Búsqueda (Texto Completo):** Utilizar un índice dedicado (ej. Elasticsearch) que almacene una versión optimizada de los documentos para búsqueda y filtrado.

**Criterios de Elección:**

* **Velocidad de Lectura/Búsqueda:** Máxima velocidad para consultas de frontend.
* **Flexibilidad de Esquema:** Facilidad para añadir nuevos atributos de juegos (ej. nuevas etiquetas o propiedades de condición).
* **Mapeo de Datos:** Necesidad de un mapeo simple para pasar datos de la BD maestra al motor de búsqueda.

**Decisión:**
Combinación de **Base de Datos Documental (MongoDB/Firestore)** como fuente maestra y un **Motor de Búsqueda (Elasticsearch)** como capa de acceso rápido.

**Sustento:**
El modelo **Documental** ofrece **Flexibilidad de Esquema** para metadatos variados. El motor de Búsqueda garantiza la **Velocidad de Lectura/Búsqueda** ultrarrápida (Decisión 4.6.1.02.1). La abstracción principal de datos será el objeto *"Product Listing"* (Juego en venta) que contiene todos los metadatos relevantes para la búsqueda y visualización.

## 02: Módulo: Gestión de Usuarios
---
### Decisión 1: Modelo de Datos para Perfiles, Roles y Autorización.

**Título:**
Estructura de Datos para Perfiles, Roles y Seguridad

**Contexto:**
El Módulo GU almacena información sensible y crítica: perfiles de usuario, roles (Comprador/Vendedor) e historial de transacciones. Se necesita un modelo de datos que garantice la integridad, la seguridad y la facilidad para realizar *joins* con datos transaccionales (Pedidos).

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ofrece transacciones ACID, integridad referencial y modelado natural para entidades interconectadas (Usuario $\rightarrow$ Roles $\rightarrow$ Historial).
* **Base de Datos de Gráfos (Neo4j):** Ideal para modelar relaciones sociales y permisos complejos, pero excesivo para un perfil de usuario simple.

**Criterios de Elección:**

* **Integridad y Relaciones:** Necesidad de garantizar la validez de los roles y el mapeo al historial de transacciones.
* **Seguridad:** El entorno SQL es maduro y ofrece buenas herramientas de seguridad a nivel de fila y columna.
* **Consultas de Acceso:** Consultas directas basadas en ID de usuario y *joins* simples para obtener el historial.

**Decisión:**
**Base de Datos Relacional (SQL)** para almacenar la entidad *User* (Perfil, Roles, Historial Básico).

**Sustento:**
El modelo **Relacional** es el estándar para datos de identidad y perfiles debido a su **Integridad** y las garantías **ACID**. Permite consultas eficientes y seguras para verificar el rol del usuario durante la autorización en otros microservicios.

## 03: Módulo: Carrito de Compras y Pedidos
---
### Decisión 1: Modelo de Datos para Pedidos y Garantía de Integridad.

**Título:**
Elección del Modelo de Datos para Transacciones Críticas

**Contexto:**
El Módulo CCP gestiona el carrito (temporal) y la creación de pedidos (persistente). Esta es la funcionalidad más crítica, requiriendo que los datos sean coherentes, atómicos y altamente confiables. Se deben registrar ítems, precios unitarios fijos y totales finales.

**Alternativas:**

* **Base de Datos NoSQL (ej. MongoDB):** Rápida y flexible, pero carece de garantías ACID robustas y transacciones distribuidas complejas (a menos que se implementen manualmente).
* **Base de Datos Relacional (SQL):** Ofrece transacciones **ACID** nativas, integridad referencial y esquemas bien definidos, ideales para flujos financieros.
**Criterios de Elección:**

* **Integridad Transaccional:** Necesidad de transacciones **ACID** para crear un pedido.
* **Consistencia:** Las referencias al usuario, artículos y pagos deben ser consistentes.
* **Estructura:** El objeto "Pedido" tiene una estructura inherentemente relacional (Pedido $\rightarrow$ Ítems).

**Decisión:**
Base de Datos Relacional (SQL) para Pedidos y Carrito Persistente.

**Sustento:**
La **Integridad Transaccional** es un requisito innegociable para la gestión de Pedidos. El modelo **Relacional** garantiza que la creación del Pedido (reservar inventario y registrar detalles financieros) sea atómica y coherente, lo cual es fundamental para el módulo de comercio electrónico.

## 04: Módulo: Sistema de Pagos
---
### Decisión 1: Modelo de Datos para el Registro de Transacciones y Sincronización de Pasarelas.

**Título:**
Abstracción de Datos para el Registro de Transacciones Financieras

**Contexto:**
El Módulo SP solo almacena el registro de la transacción (ID del pedido, monto, ID de la pasarela, estado, *token* de pago si aplica) sin custodiar datos sensibles de tarjeta. Este registro debe ser inmutable y auditable.

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ideal para registros financieros por su estricto esquema y transacciones atómicas.
* **Base de Datos Orientada a Eventos (Event Store):** Almacena el historial de pagos como una secuencia inmutable de eventos.

**Criterios de Elección:**

* **Auditoría e Inmutabilidad:** El registro de un pago no debe ser alterable una vez completado.
* **Simplicidad de Consulta:** Consulta simple para verificar el estado de un pago.
* **Integridad con Pedido:** Necesidad de una referencia estricta al ID del Pedido de CCP.

**Decisión:**
**Base de Datos Relacional (SQL)** para la entidad *Transaction Log* (Registro de Transacción).

**Sustento:**
Usar **SQL** proporciona el nivel de **Integridad** y **Auditoría** necesario para los datos financieros. La *Transaction Log* será una tabla inmutable que registra el intento de pago, el resultado y la referencia única de la pasarela de pago, esencial para la reconciliación contable.

## 05: Módulo: Logística y Envíos
---
### Decisión 1: Organización de Metadatos de Transportistas y Rastreo de Pedido.

**Título:**
Abstracción de Datos para Entidades de Logística y Seguimiento

**Contexto:**
El Módulo LE necesita datos de transportistas (tarifas, tiempos) y debe rastrear el estado de cada pedido a través de múltiples pasos (Empaquetado, En Tránsito, Entregado).

**Alternativas:**

* **Modelo de Eventos/Estados (SQL):** Una tabla `TrackingUpdates` donde cada fila es una actualización de estado con marca de tiempo.
* **Modelo Documental Anidado (NoSQL):** Un documento `Shipment` que contiene un *array* anidado de todos los `TrackingEvents`.

**Criterios de Elección:**

* **Trazabilidad Temporal:** Facilidad para consultar el historial de estado en orden.
* **Velocidad de Escritura:** Las actualizaciones de estado son frecuentes y rápidas.
* **Mapeo:** El objeto `Shipment` es una abstracción natural para la API de seguimiento.

**Decisión:**
Base de Datos Relacional (SQL) para el objeto principal *Shipment* con un campo de tipo *array*/JSON para almacenar el historial de eventos (*embedded NoSQL data within SQL*).

**Sustento:**
Usar **SQL** garantiza la **Integridad** del objeto *Shipment* (asociado al Pedido de CCP). Almacenar el historial de eventos de rastreo como un campo JSON o *Array* dentro del registro SQL combina la **Integridad Relacional** con la **Flexibilidad de Escritura** rápida del modelo NoSQL para los datos de seguimiento en tiempo real.

## 06: Módulo: Comunidad y Reseñas
---
### Decisión 1: Organización del Modelo de Datos para Reseñas y Contenido No Estructurado.

**Título:**
Abstracción de Datos y Estructura para Reseñas y Valoraciones

**Contexto:**
El Módulo CR gestiona reseñas de texto (contenido variable, no estructurado) y valoraciones numéricas (1-5 o 1-100). Es crucial poder consultar rápidamente la puntuación media de un juego y listar las reseñas más recientes o mejor valoradas.

**Alternativas:**

* **Base de Datos Relacional:** Almacenar reseñas y valoraciones en tablas. Requiere *JOINs* para calcular el promedio.
* **Base de Datos Documental/Clave-Valor:** Almacenar cada reseña como un documento y mantener un contador/promedio pre-calculado.

**Criterios de Elección:**

* **Velocidad de Lectura:** Acceso rápido a las reseñas de un producto.
* **Concurrencia de Escritura:** El sistema debe manejar muchas reseñas/comentarios simultáneos.
* **Flexibilidad:** El contenido textual (la reseña) puede variar en longitud y formato.

**Decisión:**
Base de Datos Documental (NoSQL, ej. MongoDB) para almacenar la entidad *Review*, y un campo pre-calculado en el Módulo CP para el promedio de valoración.

**Sustento:**
El modelo **Documental** es ideal para datos de texto **semiestructurados** y de alta **Concurrencia de Escritura**. Para optimizar la **Velocidad de Lectura**, el **Promedio de Valoración** se calculará asíncronamente y se enviará como metadato al Módulo CP para su visualización inmediata, evitando consultas lentas.

## 07: Módulo: Análisis de Datos y Reportes
---
### Decisión 1: Organización de Datos para Consultas Analíticas

**Título:**
Modelo de Almacenamiento y Organización para la Analítica de Datos

**Contexto:**
El Módulo ADR requiere realizar consultas complejas sobre grandes volúmenes de datos históricos (ventas, búsquedas, demografía) para generar reportes y métricas de tendencia, sin afectar los sistemas de producción.

**Alternativas:**

* **Almacenamiento en Base de Datos Relacional Normalizada:** Ineficiente y lento para consultas de agregación a través de grandes periodos de tiempo.
* **Modelo Dimensional (Data Warehouse):** Organización de datos optimizada para consultas (esquema estrella/copo de nieve), ideal para reportes **OLAP** y agregación.
* **Data Lake (Almacenamiento de Archivos Brutos):** Permite el almacenamiento de datos sin procesar, ideal para exploraciones de Machine Learning y análisis futuros.

**Criterios de Elección:**

* **Velocidad de Consulta Analítica:** Optimizar las consultas de agregación y filtros complejos.
* **Separación de Cargas:** Aislar totalmente la carga de la analítica de la carga transaccional.
* **Escalabilidad de Almacenamiento:** Manejar petabytes de datos históricos de forma rentable.

**Decisión:**
Combinación de **Data Warehouse (Modelo Dimensional)** para reportes estructurados y **Data Lake** para almacenamiento de eventos brutos (eventos de búsqueda, clics).

**Sustento:**
La utilización de un **Data Warehouse (Modelo Dimensional)** garantiza la **Velocidad de Consulta Analítica** para los reportes de ventas y tendencias estructuradas. El **Data Lake** proporciona **Escalabilidad** de almacenamiento y una fuente de datos *raw* para futuros proyectos de *Machine Learning* sobre el comportamiento de búsqueda y *churn* de usuarios.

[⬅️ Anterior](../4.6.2/4.6.2.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../4.6.4/4.6.4.md)