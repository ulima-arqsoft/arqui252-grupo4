> [4. Decisiones Iniciales de Arquitectura](../../4.md) › [4.8. Listado Consolidado](../4.8.md) › [4.8.4. Mapeo entre elementos de Arquitectura](4.8.4.md)

# 4.8.4. Gestión de Recursos

Este apartado se centra en la identificación de los recursos compartidos, el establecimiento de límites y las estrategias de arbitraje para gestionar la contención y prevenir la saturación o el colapso del sistema.

## 00: Decisiones Generales de Recursos
---
### Decisión 1: Estrategia de Protección Global y Anticascada

**Título:**
Estrategia de Protección Global de Tráfico

**Contexto:**
La API Gateway actúa como el punto único de entrada para todas las peticiones externas. Es la primera línea de defensa para aplicar políticas de protección contra la sobrecarga externa o fallos internos que puedan causar un efecto dominó (fallo en cascada) a los microservicios.

**Alternativas:**

* **Solo Rate Limiting:** Limitar solo la tasa de peticiones (RPS), sin verificar la salud del backend. No previene fallos internos.

* **Solo Circuit Breaker:** Abrir el circuito solo después de que el backend ya esté sufriendo o fallando. No previene la saturación inicial.

**Criterios de Elección:**

* **Resiliencia:** Prevenir el colapso por fallos en cascada.

* **Estabilidad:** Mantener una tasa de peticiones saludable para los backends.

* **Defensa:** Actuar como primer filtro de seguridad contra sobrecargas externas.

**Decisión:**
Implementación obligatoria de Circuit Breaker y Rate Limiting a nivel de API Gateway. El Rate Limiter se configurará con un Token Bucket Algorithm para suavizar los picos de tráfico.

**Sustento:**
El Rate Limiting previene la saturación por tráfico excesivo (externo), asegurando que los recursos downstream no se agoten inmediatamente. El Circuit Breaker monitorea la latencia y tasa de errores de los microservicios y detiene las llamadas a los servicios inestables, evitando el colapso por fallo en cascada, lo cual es crítico en una arquitectura de microservicios.

## 01: Módulo: Catálogo de Productos
---
### Decisión 1: Limitación de Conexiones a la Base de Datos

**Título:**
Estrategia de Pool de Conexiones para el Catálogo

**Contexto:**
El Catálogo es el módulo más consultado por los usuarios (lectura intensiva). Un exceso de consultas simultáneas podría agotar el *pool* de conexiones de PostgreSQL y colapsar el servicio.

**Alternativas:**

* **Pool Fijo Pequeño:** Limitar estrictamente el número de conexiones a 50. Seguro, pero podría generar latencia en picos de tráfico.
* **Pool Dinámico Grande:** Permitir hasta 200 conexiones, ajustando dinámicamente. Riesgoso para la base de datos subyacente.

**Criterios de Elección:**

* **Disponibilidad:** Mantener el servicio activo bajo alta carga de lectura.
* **Estabilidad del Motor de BD:** No saturar PostgreSQL.
* **Eficiencia de Latencia:** Minimizar el tiempo de espera de las consultas.

**Decisión:**
Se implementará un **pool de conexiones moderado (máximo 100)** en el *framework* del *backend* de CP, combinado con un *sidecar* de conexión (**Pgbouncer**) para multiplexar las conexiones.

**Sustento:**
El uso de **Pgbouncer** desacopla la aplicación de las conexiones físicas a PostgreSQL, permitiendo un *Pool Fijo* eficiente en el *backend* y el multiplexado, mejorando la **Disponibilidad** sin sobrecargar la BD.

### Decisión 2: Arbitraje de Acceso a Inventario 

**Título:**
Mecanismo de Arbitraje para Bloqueo de Inventario

**Contexto:**
La actualización del *stock* de inventario (cuando se hace un pedido) es una operación crítica que ocurre en CP y debe ser **atómica y aislada** para evitar la doble venta.

**Alternativas:**

* **Bloqueo Optimista:** Usar números de versión (*versioning*) en el registro de *stock*. Más rápido, pero puede fallar si hay alta contención (requiere reintento).
* **Bloqueo Pesimista:** Usar bloqueos a nivel de fila en la transacción de PostgreSQL. Más lento, pero garantiza la consistencia bajo alta contención.

**Criterios de Elección:**

* **Integridad del Stock:** No permitir la doble venta bajo ninguna circunstancia (máxima prioridad).
* **Escalabilidad de Escritura:** Minimizar el tiempo que dura el bloqueo.

**Decisión:**
Implementar **Bloqueo Pesimista** (**SELECT FOR UPDATE**) a nivel de fila dentro de la transacción del servicio que ajusta el inventario.

**Sustento:**
Aunque introduce una latencia mínima, el **Bloqueo Pesimista** garantiza la **Integridad del Stock** absoluta, que es un requisito de negocio no negociable para una plataforma de *e-commerce*.

## 02: Módulo: Gestión de Usuarios
---
### Decisión 1: Límite de Tasa (Rate Limiting) en Endpoints de Autenticación

**Título:**
Gestión de Recursos en Intentos de Login/Registro

**Contexto:**
Los *endpoints* de *login* y registro son vulnerables a ataques de fuerza bruta o de denegación de servicio (**DoS**) si no se limita el consumo de recursos.

**Alternativas:**

* **Rate Limit por IP:** Bloqueo basado únicamente en la dirección IP. Fácil de evadir con *proxies*.
* **Rate Limit por Usuario/Email:** Bloqueo basado en la combinación de IP y la cuenta intentada.

**Criterios de Elección:**

* **Seguridad:** Prevenir ataques de fuerza bruta.
* **Experiencia de Usuario:** No bloquear a usuarios legítimos detrás de una IP compartida.

**Decisión:**
Implementar **Rate Limiting por Usuario/Email** con un límite de 5 intentos fallidos en 5 minutos, y un límite secundario más suave por IP.

**Sustento:**
Combinar ambos límites maximiza la **Seguridad** al prevenir ataques dirigidos a cuentas específicas, mientras que el límite secundario por IP previene el abuso de recursos desde una única fuente, mejorando la **Experiencia de Usuario** frente a redes compartidas.

## 03: Módulo: Carrito de Compras y Pedidos
---
### Decisión 1: Tiempo de Vida (TTL) de los Carritos de Compra

**Título:**
Gestión de Recursos de Almacenamiento de Carrito

**Contexto:**
Los carritos de compra inactivos consumen recursos en Redis. Es necesario liberar espacio de manera eficiente y automática.

**Alternativas:**

* **TTL Largo (7 días):** Mantiene el estado del carrito por mucho tiempo. Consume más memoria.
* **TTL Corto (1 hora):** Libera memoria rápidamente. Riesgo de frustración si el usuario vuelve tarde.

**Criterios de Elección:**

* **Optimización de Memoria:** Reducir la carga en el motor Redis.
* **Experiencia de Usuario:** Permitir tiempo razonable para completar la compra.

**Decisión:**
Establecer un **Tiempo de Vida (TTL) de 48 horas** para los carritos de compra inactivos en Redis.

**Sustento:**
Un **TTL de 48 horas** es un equilibrio razonable entre la **Optimización de Memoria** y asegurar una buena **Experiencia de Usuario**, permitiendo que los usuarios regresen al día siguiente para finalizar su compra.

## 04: Módulo: Sistema de Pagos
---
### Decisión 1: Gestión de Recursos para Retries

**Título:**
Estrategia de Backoff para Llamadas a Pasarelas de Pago

**Contexto:**
Las llamadas a pasarelas de pago externas pueden fallar por problemas transitorios de red o saturación. Se necesita una estrategia de reintento que no sature la pasarela.

**Alternativas:**

* **Retries Inmediatos:** Reintentar inmediatamente. Puede colapsar la pasarela si el problema es persistente.
* **Exponential Backoff:** Aumentar el tiempo de espera exponencialmente entre reintentos.

**Criterios de Elección:**

* **Disponibilidad:** Asegurar que los pagos pasen si el fallo es transitorio.
* **Respeto a Recursos Externos:** No sobrecargar al proveedor externo.

**Decisión:**
Implementar **Exponential Backoff** (espera 1s, 2s, 4s, 8s...) con un máximo de 3 reintentos en el módulo SP.

**Sustento:**
El **Exponential Backoff** es el estándar para interactuar con sistemas externos, ya que respeta los **Recursos Externos** y les da tiempo para recuperarse, aumentando significativamente la **Disponibilidad** de la transacción.

## 05: Módulo: Logística y Envíos
---
### Decisión 1: Control de Tasa de Llamadas a Transportistas

**Título:**
Estrategia de Throttling para Integración de Transportistas

**Contexto:**
Las APIs de los transportistas tienen límites de tasa estrictos (Ej. 10 peticiones/seg). El módulo LE debe asegurarse de no exceder estos límites para evitar el bloqueo total.

**Alternativas:**

* **Colas de Tarea Sencillas (RabbitMQ):** Usar una cola que procese los trabajos a velocidad controlada.
* **Servicio de Throttling Dedicado (Redis-based):** Implementar un contador distribuido de alta precisión.

**Criterios de Elección:**

* **Cumplimiento de SLA:** No exceder los límites del proveedor externo.
* **Simplicidad Operacional:** Usar una herramienta ya elegida si es posible.

**Decisión:**
Utilizar **RabbitMQ Work Queues** con un consumidor configurado para procesar las tareas con un **retraso forzado (throttle) de 100ms (10/seg)** entre cada llamada a la API del transportista.

**Sustento:**
Aprovechar **RabbitMQ** (ya elegido en 4.6.3) para la cola de trabajo es simple y eficaz. Configurar un *Throttling* basado en el consumidor asegura el **Cumplimiento de SLA** sin requerir un nuevo servicio dedicado.

## 06: Módulo: Comunidad y Reseñas
---
### Decisión 1: Limitación de Recursos de Almacenamiento (Tamaño Máximo de Reseña)

**Título:**
Límite Máximo de Tamaño de Documento de Reseña

**Contexto:**
El módulo CR almacena reseñas en MongoDB. Se debe prevenir que usuarios maliciosos inserten documentos gigantescos que degraden el rendimiento de las consultas e incrementen el consumo de almacenamiento innecesario.

**Alternativas:**

* **Límite Alto (1MB):** Usar el límite de MongoDB. Demasiado grande para texto simple.
* **Límite Estricto (5KB):** Establecer un límite basado en el uso real de una reseña.

**Criterios de Elección:**

* **Seguridad y Costo:** Prevenir el abuso y controlar el tamaño de la BD.
* **Experiencia de Usuario:** Permitir suficiente espacio para reseñas detalladas.

**Decisión:**
Imponer un **límite de 10,000 caracteres** (aproximadamente 20KB de almacenamiento de documento) en el campo de texto de la reseña, validado en el servicio de *backend*.

**Sustento:**
Este límite proporciona suficiente espacio para reseñas muy detalladas (**Experiencia de Usuario**) mientras que previene eficazmente la sobrecarga de **Seguridad y Costo** que podría generar un documento de 1MB.

## 07: Módulo: Análisis de Datos y Reportes
---
### Decisión 1: Limitación de Consultas Analíticas (Concurrencia)

**Título:**
Arbitraje de Consultas Pesadas en el Data Warehouse

**Contexto:**
Las consultas de reporte (**OLAP**) son inherentemente lentas y consumen muchos recursos de CPU/RAM de PostgreSQL. Demasiadas consultas simultáneas colapsarán el *Data Warehouse* y afectarán la generación de reportes.

**Alternativas:**

* **Cola de Consultas:** Poner las consultas en una cola y ejecutarlas secuencialmente. Seguro, pero puede generar latencia inaceptable.
* **Límite de Concurrencia:** Permitir un número fijo y bajo de consultas simultáneas.

**Criterios de Elección:**

* **Estabilidad del Reporte:** Priorizar la finalización de los reportes sobre la velocidad.
* **Uso Eficiente de Recursos:** No permitir la saturación de CPU/RAM.

**Decisión:**
Limitar el *pool* de conexiones del módulo ADR a PostgreSQL a un **máximo de 10 conexiones concurrentes** y usar tiempos de espera (*timeouts*) estrictos (máx. 60 segundos).

**Sustento:**
Limitar la **Concurrencia** es la forma más efectiva de garantizar la **Estabilidad del Reporte** al evitar que múltiples consultas pesadas compitan por los mismos recursos de CPU y disco, asegurando que el sistema no colapse bajo carga analítica.

---

[⬅️ Anterior](../4.8.3/4.8.3.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../4.8.5/4.8.5.md)