> [4. Decisiones Iniciales de Arquitectura](../../4.md) ‚Ä∫ [4.8. Listado Consolidado](../4.8.md) ‚Ä∫ [4.8.4. Mapeo entre elementos de Arquitectura](4.8.4.md)

# 4.8.4. Gesti√≥n de Recursos

Este apartado se centra en la identificaci√≥n de los recursos compartidos, el establecimiento de l√≠mites y las estrategias de arbitraje para gestionar la contenci√≥n y prevenir la saturaci√≥n o el colapso del sistema.

## 00: Decisiones Generales de Recursos
---
### Decisi√≥n 1: Estrategia de Protecci√≥n Global y Anticascada

**T√≠tulo:**
Estrategia de Protecci√≥n Global de Tr√°fico

**Contexto:**
La API Gateway act√∫a como el punto √∫nico de entrada para todas las peticiones externas. Es la primera l√≠nea de defensa para aplicar pol√≠ticas de protecci√≥n contra la sobrecarga externa o fallos internos que puedan causar un efecto domin√≥ (fallo en cascada) a los microservicios.

**Alternativas:**

* **Solo Rate Limiting:** Limitar solo la tasa de peticiones (RPS), sin verificar la salud del backend. No previene fallos internos.

* **Solo Circuit Breaker:** Abrir el circuito solo despu√©s de que el backend ya est√© sufriendo o fallando. No previene la saturaci√≥n inicial.

**Criterios de Elecci√≥n:**

* **Resiliencia:** Prevenir el colapso por fallos en cascada.

* **Estabilidad:** Mantener una tasa de peticiones saludable para los backends.

* **Defensa:** Actuar como primer filtro de seguridad contra sobrecargas externas.

**Decisi√≥n:**
Implementaci√≥n obligatoria de Circuit Breaker y Rate Limiting a nivel de API Gateway. El Rate Limiter se configurar√° con un Token Bucket Algorithm para suavizar los picos de tr√°fico.

**Sustento:**
El Rate Limiting previene la saturaci√≥n por tr√°fico excesivo (externo), asegurando que los recursos downstream no se agoten inmediatamente. El Circuit Breaker monitorea la latencia y tasa de errores de los microservicios y detiene las llamadas a los servicios inestables, evitando el colapso por fallo en cascada, lo cual es cr√≠tico en una arquitectura de microservicios.

## 01: M√≥dulo: Cat√°logo de Productos
---
### Decisi√≥n 1: Limitaci√≥n de Conexiones a la Base de Datos

**T√≠tulo:**
Estrategia de Pool de Conexiones para el Cat√°logo

**Contexto:**
El Cat√°logo es el m√≥dulo m√°s consultado por los usuarios (lectura intensiva). Un exceso de consultas simult√°neas podr√≠a agotar el *pool* de conexiones de PostgreSQL y colapsar el servicio.

**Alternativas:**

* **Pool Fijo Peque√±o:** Limitar estrictamente el n√∫mero de conexiones a 50. Seguro, pero podr√≠a generar latencia en picos de tr√°fico.
* **Pool Din√°mico Grande:** Permitir hasta 200 conexiones, ajustando din√°micamente. Riesgoso para la base de datos subyacente.

**Criterios de Elecci√≥n:**

* **Disponibilidad:** Mantener el servicio activo bajo alta carga de lectura.
* **Estabilidad del Motor de BD:** No saturar PostgreSQL.
* **Eficiencia de Latencia:** Minimizar el tiempo de espera de las consultas.

**Decisi√≥n:**
Se implementar√° un **pool de conexiones moderado (m√°ximo 100)** en el *framework* del *backend* de CP, combinado con un *sidecar* de conexi√≥n (**Pgbouncer**) para multiplexar las conexiones.

**Sustento:**
El uso de **Pgbouncer** desacopla la aplicaci√≥n de las conexiones f√≠sicas a PostgreSQL, permitiendo un *Pool Fijo* eficiente en el *backend* y el multiplexado, mejorando la **Disponibilidad** sin sobrecargar la BD.

### Decisi√≥n 2: Arbitraje de Acceso a Inventario 

**T√≠tulo:**
Mecanismo de Arbitraje para Bloqueo de Inventario

**Contexto:**
La actualizaci√≥n del *stock* de inventario (cuando se hace un pedido) es una operaci√≥n cr√≠tica que ocurre en CP y debe ser **at√≥mica y aislada** para evitar la doble venta.

**Alternativas:**

* **Bloqueo Optimista:** Usar n√∫meros de versi√≥n (*versioning*) en el registro de *stock*. M√°s r√°pido, pero puede fallar si hay alta contenci√≥n (requiere reintento).
* **Bloqueo Pesimista:** Usar bloqueos a nivel de fila en la transacci√≥n de PostgreSQL. M√°s lento, pero garantiza la consistencia bajo alta contenci√≥n.

**Criterios de Elecci√≥n:**

* **Integridad del Stock:** No permitir la doble venta bajo ninguna circunstancia (m√°xima prioridad).
* **Escalabilidad de Escritura:** Minimizar el tiempo que dura el bloqueo.

**Decisi√≥n:**
Implementar **Bloqueo Pesimista** (**SELECT FOR UPDATE**) a nivel de fila dentro de la transacci√≥n del servicio que ajusta el inventario.

**Sustento:**
Aunque introduce una latencia m√≠nima, el **Bloqueo Pesimista** garantiza la **Integridad del Stock** absoluta, que es un requisito de negocio no negociable para una plataforma de *e-commerce*.

## 02: M√≥dulo: Gesti√≥n de Usuarios
---
### Decisi√≥n 1: L√≠mite de Tasa (Rate Limiting) en Endpoints de Autenticaci√≥n

**T√≠tulo:**
Gesti√≥n de Recursos en Intentos de Login/Registro

**Contexto:**
Los *endpoints* de *login* y registro son vulnerables a ataques de fuerza bruta o de denegaci√≥n de servicio (**DoS**) si no se limita el consumo de recursos.

**Alternativas:**

* **Rate Limit por IP:** Bloqueo basado √∫nicamente en la direcci√≥n IP. F√°cil de evadir con *proxies*.
* **Rate Limit por Usuario/Email:** Bloqueo basado en la combinaci√≥n de IP y la cuenta intentada.

**Criterios de Elecci√≥n:**

* **Seguridad:** Prevenir ataques de fuerza bruta.
* **Experiencia de Usuario:** No bloquear a usuarios leg√≠timos detr√°s de una IP compartida.

**Decisi√≥n:**
Implementar **Rate Limiting por Usuario/Email** con un l√≠mite de 5 intentos fallidos en 5 minutos, y un l√≠mite secundario m√°s suave por IP.

**Sustento:**
Combinar ambos l√≠mites maximiza la **Seguridad** al prevenir ataques dirigidos a cuentas espec√≠ficas, mientras que el l√≠mite secundario por IP previene el abuso de recursos desde una √∫nica fuente, mejorando la **Experiencia de Usuario** frente a redes compartidas.

## 03: M√≥dulo: Carrito de Compras y Pedidos
---
### Decisi√≥n 1: Tiempo de Vida (TTL) de los Carritos de Compra

**T√≠tulo:**
Gesti√≥n de Recursos de Almacenamiento de Carrito

**Contexto:**
Los carritos de compra inactivos consumen recursos en Redis. Es necesario liberar espacio de manera eficiente y autom√°tica.

**Alternativas:**

* **TTL Largo (7 d√≠as):** Mantiene el estado del carrito por mucho tiempo. Consume m√°s memoria.
* **TTL Corto (1 hora):** Libera memoria r√°pidamente. Riesgo de frustraci√≥n si el usuario vuelve tarde.

**Criterios de Elecci√≥n:**

* **Optimizaci√≥n de Memoria:** Reducir la carga en el motor Redis.
* **Experiencia de Usuario:** Permitir tiempo razonable para completar la compra.

**Decisi√≥n:**
Establecer un **Tiempo de Vida (TTL) de 48 horas** para los carritos de compra inactivos en Redis.

**Sustento:**
Un **TTL de 48 horas** es un equilibrio razonable entre la **Optimizaci√≥n de Memoria** y asegurar una buena **Experiencia de Usuario**, permitiendo que los usuarios regresen al d√≠a siguiente para finalizar su compra.

## 04: M√≥dulo: Sistema de Pagos
---
### Decisi√≥n 1: Gesti√≥n de Recursos para Retries

**T√≠tulo:**
Estrategia de Backoff para Llamadas a Pasarelas de Pago

**Contexto:**
Las llamadas a pasarelas de pago externas pueden fallar por problemas transitorios de red o saturaci√≥n. Se necesita una estrategia de reintento que no sature la pasarela.

**Alternativas:**

* **Retries Inmediatos:** Reintentar inmediatamente. Puede colapsar la pasarela si el problema es persistente.
* **Exponential Backoff:** Aumentar el tiempo de espera exponencialmente entre reintentos.

**Criterios de Elecci√≥n:**

* **Disponibilidad:** Asegurar que los pagos pasen si el fallo es transitorio.
* **Respeto a Recursos Externos:** No sobrecargar al proveedor externo.

**Decisi√≥n:**
Implementar **Exponential Backoff** (espera 1s, 2s, 4s, 8s...) con un m√°ximo de 3 reintentos en el m√≥dulo SP.

**Sustento:**
El **Exponential Backoff** es el est√°ndar para interactuar con sistemas externos, ya que respeta los **Recursos Externos** y les da tiempo para recuperarse, aumentando significativamente la **Disponibilidad** de la transacci√≥n.

## 05: M√≥dulo: Log√≠stica y Env√≠os
---
### Decisi√≥n 1: Control de Tasa de Llamadas a Transportistas

**T√≠tulo:**
Estrategia de Throttling para Integraci√≥n de Transportistas

**Contexto:**
Las APIs de los transportistas tienen l√≠mites de tasa estrictos (Ej. 10 peticiones/seg). El m√≥dulo LE debe asegurarse de no exceder estos l√≠mites para evitar el bloqueo total.

**Alternativas:**

* **Colas de Tarea Sencillas (RabbitMQ):** Usar una cola que procese los trabajos a velocidad controlada.
* **Servicio de Throttling Dedicado (Redis-based):** Implementar un contador distribuido de alta precisi√≥n.

**Criterios de Elecci√≥n:**

* **Cumplimiento de SLA:** No exceder los l√≠mites del proveedor externo.
* **Simplicidad Operacional:** Usar una herramienta ya elegida si es posible.

**Decisi√≥n:**
Utilizar **RabbitMQ Work Queues** con un consumidor configurado para procesar las tareas con un **retraso forzado (throttle) de 100ms (10/seg)** entre cada llamada a la API del transportista.

**Sustento:**
Aprovechar **RabbitMQ** (ya elegido en 4.6.3) para la cola de trabajo es simple y eficaz. Configurar un *Throttling* basado en el consumidor asegura el **Cumplimiento de SLA** sin requerir un nuevo servicio dedicado.

## 06: M√≥dulo: Comunidad y Rese√±as
---
### Decisi√≥n 1: Limitaci√≥n de Recursos de Almacenamiento (Tama√±o M√°ximo de Rese√±a)

**T√≠tulo:**
L√≠mite M√°ximo de Tama√±o de Documento de Rese√±a

**Contexto:**
El m√≥dulo CR almacena rese√±as en MongoDB. Se debe prevenir que usuarios maliciosos inserten documentos gigantescos que degraden el rendimiento de las consultas e incrementen el consumo de almacenamiento innecesario.

**Alternativas:**

* **L√≠mite Alto (1MB):** Usar el l√≠mite de MongoDB. Demasiado grande para texto simple.
* **L√≠mite Estricto (5KB):** Establecer un l√≠mite basado en el uso real de una rese√±a.

**Criterios de Elecci√≥n:**

* **Seguridad y Costo:** Prevenir el abuso y controlar el tama√±o de la BD.
* **Experiencia de Usuario:** Permitir suficiente espacio para rese√±as detalladas.

**Decisi√≥n:**
Imponer un **l√≠mite de 10,000 caracteres** (aproximadamente 20KB de almacenamiento de documento) en el campo de texto de la rese√±a, validado en el servicio de *backend*.

**Sustento:**
Este l√≠mite proporciona suficiente espacio para rese√±as muy detalladas (**Experiencia de Usuario**) mientras que previene eficazmente la sobrecarga de **Seguridad y Costo** que podr√≠a generar un documento de 1MB.

## 07: M√≥dulo: An√°lisis de Datos y Reportes
---
### Decisi√≥n 1: Limitaci√≥n de Consultas Anal√≠ticas (Concurrencia)

**T√≠tulo:**
Arbitraje de Consultas Pesadas en el Data Warehouse

**Contexto:**
Las consultas de reporte (**OLAP**) son inherentemente lentas y consumen muchos recursos de CPU/RAM de PostgreSQL. Demasiadas consultas simult√°neas colapsar√°n el *Data Warehouse* y afectar√°n la generaci√≥n de reportes.

**Alternativas:**

* **Cola de Consultas:** Poner las consultas en una cola y ejecutarlas secuencialmente. Seguro, pero puede generar latencia inaceptable.
* **L√≠mite de Concurrencia:** Permitir un n√∫mero fijo y bajo de consultas simult√°neas.

**Criterios de Elecci√≥n:**

* **Estabilidad del Reporte:** Priorizar la finalizaci√≥n de los reportes sobre la velocidad.
* **Uso Eficiente de Recursos:** No permitir la saturaci√≥n de CPU/RAM.

**Decisi√≥n:**
Limitar el *pool* de conexiones del m√≥dulo ADR a PostgreSQL a un **m√°ximo de 10 conexiones concurrentes** y usar tiempos de espera (*timeouts*) estrictos (m√°x. 60 segundos).

**Sustento:**
Limitar la **Concurrencia** es la forma m√°s efectiva de garantizar la **Estabilidad del Reporte** al evitar que m√∫ltiples consultas pesadas compitan por los mismos recursos de CPU y disco, asegurando que el sistema no colapse bajo carga anal√≠tica.

---

[‚¨ÖÔ∏è Anterior](../4.8.3/4.8.3.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../4.8.5/4.8.5.md)