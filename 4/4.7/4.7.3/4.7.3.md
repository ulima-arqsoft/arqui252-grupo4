> [4. Decisiones Iniciales de Arquitectura](../../4.md) ‚Ä∫ [4.7. Listado Consolidado](../4.7.md) ‚Ä∫ [4.7.3. Modelo de Datos](4.7.3.md)

# 4.7.3. Modelo de Datos

Este apartado define la elecci√≥n de las abstracciones de datos, la organizaci√≥n de la persistencia y la estrategia de mapeo para los microservicios de GameVault.

## 00: Decisiones Generales
---
### Decisi√≥n 1: Estrategia de Persistencia por M√≥dulo

**T√≠tulo:**
Elecci√≥n del Modelo de Persistencia (Pol√≠glota) Basado en las Necesidades del M√≥dulo

**Contexto:**
Dado que GameVault utiliza una arquitectura de microservicios, cada m√≥dulo tiene responsabilidades de datos fundamentalmente diferentes.

* **Cat√°logo de Productos (CP):** Datos masivos, est√°ticos, con alta necesidad de b√∫squeda y filtrado complejos.
* **Carrito y Pedidos (CCP):** Datos transaccionales, relacionales, que requieren alta integridad (**ACID**).
* **Comunidad y Rese√±as (CR):** Datos semiestructurados (texto de rese√±as, comentarios) y alta concurrencia de escritura

**Alternativas:**

* **Persistencia Homog√©nea (Solo SQL):** Usar una √∫nica tecnolog√≠a relacional (ej. PostgreSQL) para todos los m√≥dulos. Ofrece consistencia y familiaridad, pero es ineficiente para b√∫squedas de texto y anal√≠tica.
* **Persistencia Pol√≠glota:** Usar la tecnolog√≠a de base de datos m√°s adecuada para cada microservicio. Ofrece rendimiento y escalabilidad √≥ptimos por dominio.

**Criterios de Elecci√≥n:**

* **Optimizaci√≥n de Rendimiento:** Usar el motor adecuado para la carga de trabajo (transaccional vs. b√∫squeda).
* **Escalabilidad:** Permitir que los datos masivos del Cat√°logo y los transaccionales escalen de forma independiente.
* **Integridad de Datos:** Garantizar la consistencia en los m√≥dulos de venta (CCP y SP).

**Decisi√≥n:**
Se adopta una estrategia de **Persistencia Pol√≠glota**, seleccionando modelos de bases de datos diferentes seg√∫n la responsabilidad de cada m√≥dulo.

**Sustento:**
El enfoque pol√≠glota es indispensable en microservicios, ya que optimiza el **Rendimiento** y la **Escalabilidad**. Se utilizar√° un modelo de datos **relacional (SQL)** para asegurar la **Integridad** en flujos cr√≠ticos (Pedidos, Usuarios) y modelos **NoSQL/Motores de B√∫squeda** para datos de alta velocidad o masividad (Cat√°logo, Rese√±as).

## 01: M√≥dulo: Cat√°logo de Productos
---
### Decisi√≥n 1: Organizaci√≥n del Modelo de Datos para Metadatos y B√∫squeda

**T√≠tulo:**
Organizaci√≥n y Abstracci√≥n de Datos para el Cat√°logo de Productos

**Contexto:**
El Cat√°logo debe almacenar millones de metadatos de juegos (t√≠tulo, descripci√≥n, g√©nero, consola, rareza, condici√≥n). Los datos est√°n altamente interconectados (un juego tiene muchos g√©neros y plataformas), y la b√∫squeda es el requisito de acceso principal.

**Alternativas:**

* **Modelo Relacional Estricto (Normalizado):** Tablas separadas para Juegos, Consolas, G√©neros. Garantiza la integridad, pero las consultas de b√∫squeda y los *JOINs* son lentos.
* **Modelo Documental (Desnormalizado):** Almacenar toda la informaci√≥n de un juego como un √∫nico documento JSON. Optimiza la lectura y permite una ingesti√≥n flexible de metadatos.
* **√çndice de B√∫squeda (Texto Completo):** Utilizar un √≠ndice dedicado (ej. Elasticsearch) que almacene una versi√≥n optimizada de los documentos para b√∫squeda y filtrado.

**Criterios de Elecci√≥n:**

* **Velocidad de Lectura/B√∫squeda:** M√°xima velocidad para consultas de frontend.
* **Flexibilidad de Esquema:** Facilidad para a√±adir nuevos atributos de juegos (ej. nuevas etiquetas o propiedades de condici√≥n).
* **Mapeo de Datos:** Necesidad de un mapeo simple para pasar datos de la BD maestra al motor de b√∫squeda.

**Decisi√≥n:**
Combinaci√≥n de **Base de Datos Documental (MongoDB/Firestore)** como fuente maestra y un **Motor de B√∫squeda (Elasticsearch)** como capa de acceso r√°pido.

**Sustento:**
El modelo **Documental** ofrece **Flexibilidad de Esquema** para metadatos variados. El motor de B√∫squeda garantiza la **Velocidad de Lectura/B√∫squeda** ultrarr√°pida (Decisi√≥n 4.6.1.02.1). La abstracci√≥n principal de datos ser√° el objeto *"Product Listing"* (Juego en venta) que contiene todos los metadatos relevantes para la b√∫squeda y visualizaci√≥n.

## 02: M√≥dulo: Gesti√≥n de Usuarios
---
### Decisi√≥n 1: Modelo de Datos para Perfiles, Roles y Autorizaci√≥n.

**T√≠tulo:**
Estructura de Datos para Perfiles, Roles y Seguridad

**Contexto:**
El M√≥dulo GU almacena informaci√≥n sensible y cr√≠tica: perfiles de usuario, roles (Comprador/Vendedor) e historial de transacciones. Se necesita un modelo de datos que garantice la integridad, la seguridad y la facilidad para realizar *joins* con datos transaccionales (Pedidos).

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ofrece transacciones ACID, integridad referencial y modelado natural para entidades interconectadas (Usuario $\rightarrow$ Roles $\rightarrow$ Historial).
* **Base de Datos de Gr√°fos (Neo4j):** Ideal para modelar relaciones sociales y permisos complejos, pero excesivo para un perfil de usuario simple.

**Criterios de Elecci√≥n:**

* **Integridad y Relaciones:** Necesidad de garantizar la validez de los roles y el mapeo al historial de transacciones.
* **Seguridad:** El entorno SQL es maduro y ofrece buenas herramientas de seguridad a nivel de fila y columna.
* **Consultas de Acceso:** Consultas directas basadas en ID de usuario y *joins* simples para obtener el historial.

**Decisi√≥n:**
**Base de Datos Relacional (SQL)** para almacenar la entidad *User* (Perfil, Roles, Historial B√°sico).

**Sustento:**
El modelo **Relacional** es el est√°ndar para datos de identidad y perfiles debido a su **Integridad** y las garant√≠as **ACID**. Permite consultas eficientes y seguras para verificar el rol del usuario durante la autorizaci√≥n en otros microservicios.

## **03: M√≥dulo: Carrito de Compras y Pedidos**
---
### **Decisi√≥n 1: Modelo de Datos para Pedidos y Garant√≠a de Integridad.**

**T√≠tulo:**
Elecci√≥n del Modelo de Datos para Transacciones Cr√≠ticas (Pedidos) y Datos Vol√°tiles (Carrito)

**Contexto:**
El M√≥dulo CCP gestiona el **carrito de compras** (datos vol√°tiles y de acceso r√°pido) y la **creaci√≥n de pedidos** (datos persistentes y cr√≠ticos). Se deben registrar √≠tems, precios unitarios fijos y totales finales, requiriendo que los datos de los pedidos sean coherentes, at√≥micos y confiables.

**Alternativas:**

* **Modelo H√≠brido (Redis + SQL):** Usar Redis para la gesti√≥n del carrito de compras por su alta velocidad y SQL (PostgreSQL) para la persistencia de los pedidos, aprovechando sus garant√≠as ACID. **(Alineado a las restricciones).**
* **Modelo Relacional √önico (SQL):** Usar PostgreSQL para ambas funcionalidades. (Potencial cuello de botella y lentitud en la gesti√≥n del carrito).

**Criterios de Elecci√≥n:**

* **Rendimiento del Carrito:** La velocidad de acceso y modificaci√≥n del carrito es crucial para la **Usabilidad** y la experiencia de compra; una base de datos en memoria como Redis es ideal para esto.
* **Integridad Transaccional del Pedido:** Este es un requisito no negociable. Un modelo relacional garantiza que la creaci√≥n de un pedido sea una operaci√≥n at√≥mica, consistente y duradera (ACID), lo que es fundamental para la **Confiabilidad** del sistema.
* **Cumplimiento de Restricciones:** La decisi√≥n debe respetar la restricci√≥n expl√≠cita del proyecto que exige el uso de **Redis para el carrito y PostgreSQL para los pedidos**.

**Decisi√≥n:**
Modelo H√≠brido (Redis + SQL).

**Sustento:**
Esta decisi√≥n cumple con las **restricciones del proyecto** y optimiza la arquitectura para cada caso de uso. **Redis** garantiza el **Rendimiento** necesario para la volatilidad del carrito de compras, mientras que **PostgreSQL** proporciona la **Integridad Transaccional** y la **Confiabilidad** indispensables para el almacenamiento persistente y auditable de los pedidos.

***

## **04: M√≥dulo: Sistema de Pagos**
---
### **Decisi√≥n 1: Modelo de Datos para el Registro de Transacciones y Sincronizaci√≥n de Pasarelas.**

**T√≠tulo:**
Modelo de Datos para el Registro Inmutable de Transacciones Financieras

**Contexto:**
El M√≥dulo SP solo almacena el registro de la transacci√≥n (ID del pedido, monto, ID de la pasarela, estado, *token* de pago si aplica) sin custodiar datos sensibles de tarjeta. Este registro debe ser inmutable y auditable, con una referencia estricta al pedido correspondiente en el M√≥dulo CCP.

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ideal para registros financieros por su estricto esquema, integridad referencial y transacciones at√≥micas. **(Alineado a las restricciones).**
* **Base de Datos NoSQL (MongoDB):** Flexible, pero su modelo de consistencia eventual y falta de integridad referencial nativa no son ideales para registros financieros cr√≠ticos.

**Criterios de Elecci√≥n:**

* **Auditor√≠a e Inmutabilidad:** Para la **Trazabilidad** y **Seguridad**, es crucial que un registro de pago, una vez escrito, no pueda ser modificado, solo anulado mediante una nueva transacci√≥n.
* **Integridad Referencial:** Garantiza que cada pago est√© asociado a un pedido v√°lido y existente, previniendo registros de pago "hu√©rfanos". Esto es una caracter√≠stica clave de las bases de datos relacionales.
* **Simplicidad de Consulta:** Un esquema SQL estructurado facilita la generaci√≥n de reportes financieros y la verificaci√≥n del estado de las transacciones, lo cual es vital para la operaci√≥n del negocio.

**Decisi√≥n:**
Base de Datos Relacional (SQL).

**Sustento:**
Usar **PostgreSQL** (seg√∫n la restricci√≥n del proyecto) proporciona el nivel indispensable de **Integridad Referencial** y **Auditor√≠a** para los datos financieros. La *Transaction Log* ser√° una tabla que funciona como un registro inmutable, garantizando que cada transacci√≥n est√© correctamente vinculada a un pedido y que su historial sea confiable para la reconciliaci√≥n contable.

## 05: M√≥dulo: Comunidad y Rese√±as
---
### Decisi√≥n 1: Organizaci√≥n del Modelo de Datos para Rese√±as y Contenido No Estructurado.

**T√≠tulo:**
Abstracci√≥n de Datos y Estructura para Rese√±as y Valoraciones

**Contexto:**
El M√≥dulo CR gestiona rese√±as de texto (contenido variable, no estructurado) y valoraciones num√©ricas (1-5 o 1-100). Es crucial poder consultar r√°pidamente la puntuaci√≥n media de un juego y listar las rese√±as m√°s recientes o mejor valoradas.

**Alternativas:**

* **Base de Datos Relacional:** Almacenar rese√±as y valoraciones en tablas. Requiere *JOINs* para calcular el promedio.
* **Base de Datos Documental/Clave-Valor:** Almacenar cada rese√±a como un documento y mantener un contador/promedio pre-calculado.

**Criterios de Elecci√≥n:**

* **Velocidad de Lectura:** Acceso r√°pido a las rese√±as de un producto.
* **Concurrencia de Escritura:** El sistema debe manejar muchas rese√±as/comentarios simult√°neos.
* **Flexibilidad:** El contenido textual (la rese√±a) puede variar en longitud y formato.

**Decisi√≥n:**
Base de Datos Documental (NoSQL, ej. MongoDB) para almacenar la entidad *Review*, y un campo pre-calculado en el M√≥dulo CP para el promedio de valoraci√≥n.

**Sustento:**
El modelo **Documental** es ideal para datos de texto **semiestructurados** y de alta **Concurrencia de Escritura**. Para optimizar la **Velocidad de Lectura**, el **Promedio de Valoraci√≥n** se calcular√° as√≠ncronamente y se enviar√° como metadato al M√≥dulo CP para su visualizaci√≥n inmediata, evitando consultas lentas.

## 06: M√≥dulo: An√°lisis de Datos y Reportes
---
### Decisi√≥n 1: Organizaci√≥n de Datos para Consultas Anal√≠ticas

**T√≠tulo:**
Modelo de Almacenamiento y Organizaci√≥n para la Anal√≠tica de Datos

**Contexto:**
El M√≥dulo ADR requiere realizar consultas complejas sobre grandes vol√∫menes de datos hist√≥ricos (ventas, b√∫squedas, demograf√≠a) para generar reportes y m√©tricas de tendencia, sin afectar los sistemas de producci√≥n.

**Alternativas:**

* **Almacenamiento en Base de Datos Relacional Normalizada:** Ineficiente y lento para consultas de agregaci√≥n a trav√©s de grandes periodos de tiempo.
* **Modelo Dimensional (Data Warehouse):** Organizaci√≥n de datos optimizada para consultas (esquema estrella/copo de nieve), ideal para reportes **OLAP** y agregaci√≥n.
* **Data Lake (Almacenamiento de Archivos Brutos):** Permite el almacenamiento de datos sin procesar, ideal para exploraciones de Machine Learning y an√°lisis futuros.

**Criterios de Elecci√≥n:**

* **Velocidad de Consulta Anal√≠tica:** Optimizar las consultas de agregaci√≥n y filtros complejos.
* **Separaci√≥n de Cargas:** Aislar totalmente la carga de la anal√≠tica de la carga transaccional.
* **Escalabilidad de Almacenamiento:** Manejar petabytes de datos hist√≥ricos de forma rentable.

**Decisi√≥n:**
Combinaci√≥n de **Data Warehouse (Modelo Dimensional)** para reportes estructurados y **Data Lake** para almacenamiento de eventos brutos (eventos de b√∫squeda, clics).

**Sustento:**
La utilizaci√≥n de un **Data Warehouse (Modelo Dimensional)** garantiza la **Velocidad de Consulta Anal√≠tica** para los reportes de ventas y tendencias estructuradas. El **Data Lake** proporciona **Escalabilidad** de almacenamiento y una fuente de datos *raw* para futuros proyectos de *Machine Learning* sobre el comportamiento de b√∫squeda y *churn* de usuarios.

---

[‚¨ÖÔ∏è Anterior](../4.7.2/4.7.2.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../4.7.4/4.7.4.md)