> [4. Decisiones Iniciales de Arquitectura](../../4.md) › [4.7. Listado Consolidado](../4.7.md) › [4.7.3. Modelo de Datos](4.7.3.md)

# 4.7.3. Modelo de Datos

Este apartado define la elección de las abstracciones de datos, la organización de la persistencia y la estrategia de mapeo para los microservicios de GameVault.

## 00: Decisiones Generales
---
### Decisión 1: Estrategia de Persistencia por Módulo

**Título:**
Elección del Modelo de Persistencia (Políglota) Basado en las Necesidades del Módulo

**Contexto:**
Dado que GameVault utiliza una arquitectura de microservicios, cada módulo tiene responsabilidades de datos fundamentalmente diferentes.

* **Catálogo de Productos (CP):** Datos masivos, estáticos, con alta necesidad de búsqueda y filtrado complejos.
* **Carrito y Pedidos (CCP):** Datos transaccionales, relacionales, que requieren alta integridad (**ACID**).
* **Comunidad y Reseñas (CR):** Datos semiestructurados (texto de reseñas, comentarios) y alta concurrencia de escritura

**Alternativas:**

* **Persistencia Homogénea (Solo SQL):** Usar una única tecnología relacional (ej. PostgreSQL) para todos los módulos. Ofrece consistencia y familiaridad, pero es ineficiente para búsquedas de texto y analítica.
* **Persistencia Políglota:** Usar la tecnología de base de datos más adecuada para cada microservicio. Ofrece rendimiento y escalabilidad óptimos por dominio.

**Criterios de Elección:**

* **Optimización de Rendimiento:** Usar el motor adecuado para la carga de trabajo (transaccional vs. búsqueda).
* **Escalabilidad:** Permitir que los datos masivos del Catálogo y los transaccionales escalen de forma independiente.
* **Integridad de Datos:** Garantizar la consistencia en los módulos de venta (CCP y SP).

**Decisión:**
Se adopta una estrategia de **Persistencia Políglota**, seleccionando modelos de bases de datos diferentes según la responsabilidad de cada módulo.

**Sustento:**
El enfoque políglota es indispensable en microservicios, ya que optimiza el **Rendimiento** y la **Escalabilidad**. Se utilizará un modelo de datos **relacional (SQL)** para asegurar la **Integridad** en flujos críticos (Pedidos, Usuarios) y modelos **NoSQL/Motores de Búsqueda** para datos de alta velocidad o masividad (Catálogo, Reseñas).

## 01: Módulo: Catálogo de Productos
---
### Decisión 1: Organización del Modelo de Datos para Metadatos y Búsqueda

**Título:**
Organización y Abstracción de Datos para el Catálogo de Productos

**Contexto:**
El Catálogo debe almacenar millones de metadatos de juegos (título, descripción, género, consola, rareza, condición). Los datos están altamente interconectados (un juego tiene muchos géneros y plataformas), y la búsqueda es el requisito de acceso principal.

**Alternativas:**

* **Modelo Relacional Estricto (Normalizado):** Tablas separadas para Juegos, Consolas, Géneros. Garantiza la integridad, pero las consultas de búsqueda y los *JOINs* son lentos.
* **Modelo Documental (Desnormalizado):** Almacenar toda la información de un juego como un único documento JSON. Optimiza la lectura y permite una ingestión flexible de metadatos.
* **Índice de Búsqueda (Texto Completo):** Utilizar un índice dedicado (ej. Elasticsearch) que almacene una versión optimizada de los documentos para búsqueda y filtrado.

**Criterios de Elección:**

* **Velocidad de Lectura/Búsqueda:** Máxima velocidad para consultas de frontend.
* **Flexibilidad de Esquema:** Facilidad para añadir nuevos atributos de juegos (ej. nuevas etiquetas o propiedades de condición).
* **Mapeo de Datos:** Necesidad de un mapeo simple para pasar datos de la BD maestra al motor de búsqueda.

**Decisión:**
Combinación de **Base de Datos Documental (MongoDB/Firestore)** como fuente maestra y un **Motor de Búsqueda (Elasticsearch)** como capa de acceso rápido.

**Sustento:**
El modelo **Documental** ofrece **Flexibilidad de Esquema** para metadatos variados. El motor de Búsqueda garantiza la **Velocidad de Lectura/Búsqueda** ultrarrápida (Decisión 4.6.1.02.1). La abstracción principal de datos será el objeto *"Product Listing"* (Juego en venta) que contiene todos los metadatos relevantes para la búsqueda y visualización.

## 02: Módulo: Gestión de Usuarios
---
### Decisión 1: Modelo de Datos para Perfiles, Roles y Autorización.

**Título:**
Estructura de Datos para Perfiles, Roles y Seguridad

**Contexto:**
El Módulo GU almacena información sensible y crítica: perfiles de usuario, roles (Comprador/Vendedor) e historial de transacciones. Se necesita un modelo de datos que garantice la integridad, la seguridad y la facilidad para realizar *joins* con datos transaccionales (Pedidos).

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ofrece transacciones ACID, integridad referencial y modelado natural para entidades interconectadas (Usuario $\rightarrow$ Roles $\rightarrow$ Historial).
* **Base de Datos de Gráfos (Neo4j):** Ideal para modelar relaciones sociales y permisos complejos, pero excesivo para un perfil de usuario simple.

**Criterios de Elección:**

* **Integridad y Relaciones:** Necesidad de garantizar la validez de los roles y el mapeo al historial de transacciones.
* **Seguridad:** El entorno SQL es maduro y ofrece buenas herramientas de seguridad a nivel de fila y columna.
* **Consultas de Acceso:** Consultas directas basadas en ID de usuario y *joins* simples para obtener el historial.

**Decisión:**
**Base de Datos Relacional (SQL)** para almacenar la entidad *User* (Perfil, Roles, Historial Básico).

**Sustento:**
El modelo **Relacional** es el estándar para datos de identidad y perfiles debido a su **Integridad** y las garantías **ACID**. Permite consultas eficientes y seguras para verificar el rol del usuario durante la autorización en otros microservicios.

## **03: Módulo: Carrito de Compras y Pedidos**
---
### **Decisión 1: Modelo de Datos para Pedidos y Garantía de Integridad.**

**Título:**
Elección del Modelo de Datos para Transacciones Críticas (Pedidos) y Datos Volátiles (Carrito)

**Contexto:**
El Módulo CCP gestiona el **carrito de compras** (datos volátiles y de acceso rápido) y la **creación de pedidos** (datos persistentes y críticos). Se deben registrar ítems, precios unitarios fijos y totales finales, requiriendo que los datos de los pedidos sean coherentes, atómicos y confiables.

**Alternativas:**

* **Modelo Híbrido (Redis + SQL):** Usar Redis para la gestión del carrito de compras por su alta velocidad y SQL (PostgreSQL) para la persistencia de los pedidos, aprovechando sus garantías ACID. **(Alineado a las restricciones).**
* **Modelo Relacional Único (SQL):** Usar PostgreSQL para ambas funcionalidades. (Potencial cuello de botella y lentitud en la gestión del carrito).

**Criterios de Elección:**

* **Rendimiento del Carrito:** La velocidad de acceso y modificación del carrito es crucial para la **Usabilidad** y la experiencia de compra; una base de datos en memoria como Redis es ideal para esto.
* **Integridad Transaccional del Pedido:** Este es un requisito no negociable. Un modelo relacional garantiza que la creación de un pedido sea una operación atómica, consistente y duradera (ACID), lo que es fundamental para la **Confiabilidad** del sistema.
* **Cumplimiento de Restricciones:** La decisión debe respetar la restricción explícita del proyecto que exige el uso de **Redis para el carrito y PostgreSQL para los pedidos**.

**Decisión:**
Modelo Híbrido (Redis + SQL).

**Sustento:**
Esta decisión cumple con las **restricciones del proyecto** y optimiza la arquitectura para cada caso de uso. **Redis** garantiza el **Rendimiento** necesario para la volatilidad del carrito de compras, mientras que **PostgreSQL** proporciona la **Integridad Transaccional** y la **Confiabilidad** indispensables para el almacenamiento persistente y auditable de los pedidos.

***

## **04: Módulo: Sistema de Pagos**
---
### **Decisión 1: Modelo de Datos para el Registro de Transacciones y Sincronización de Pasarelas.**

**Título:**
Modelo de Datos para el Registro Inmutable de Transacciones Financieras

**Contexto:**
El Módulo SP solo almacena el registro de la transacción (ID del pedido, monto, ID de la pasarela, estado, *token* de pago si aplica) sin custodiar datos sensibles de tarjeta. Este registro debe ser inmutable y auditable, con una referencia estricta al pedido correspondiente en el Módulo CCP.

**Alternativas:**

* **Base de Datos Relacional (SQL):** Ideal para registros financieros por su estricto esquema, integridad referencial y transacciones atómicas. **(Alineado a las restricciones).**
* **Base de Datos NoSQL (MongoDB):** Flexible, pero su modelo de consistencia eventual y falta de integridad referencial nativa no son ideales para registros financieros críticos.

**Criterios de Elección:**

* **Auditoría e Inmutabilidad:** Para la **Trazabilidad** y **Seguridad**, es crucial que un registro de pago, una vez escrito, no pueda ser modificado, solo anulado mediante una nueva transacción.
* **Integridad Referencial:** Garantiza que cada pago esté asociado a un pedido válido y existente, previniendo registros de pago "huérfanos". Esto es una característica clave de las bases de datos relacionales.
* **Simplicidad de Consulta:** Un esquema SQL estructurado facilita la generación de reportes financieros y la verificación del estado de las transacciones, lo cual es vital para la operación del negocio.

**Decisión:**
Base de Datos Relacional (SQL).

**Sustento:**
Usar **PostgreSQL** (según la restricción del proyecto) proporciona el nivel indispensable de **Integridad Referencial** y **Auditoría** para los datos financieros. La *Transaction Log* será una tabla que funciona como un registro inmutable, garantizando que cada transacción esté correctamente vinculada a un pedido y que su historial sea confiable para la reconciliación contable.

## 05: Módulo: Comunidad y Reseñas
---
### Decisión 1: Organización del Modelo de Datos para Reseñas y Contenido No Estructurado.

**Título:**
Abstracción de Datos y Estructura para Reseñas y Valoraciones

**Contexto:**
El Módulo CR gestiona reseñas de texto (contenido variable, no estructurado) y valoraciones numéricas (1-5 o 1-100). Es crucial poder consultar rápidamente la puntuación media de un juego y listar las reseñas más recientes o mejor valoradas.

**Alternativas:**

* **Base de Datos Relacional:** Almacenar reseñas y valoraciones en tablas. Requiere *JOINs* para calcular el promedio.
* **Base de Datos Documental/Clave-Valor:** Almacenar cada reseña como un documento y mantener un contador/promedio pre-calculado.

**Criterios de Elección:**

* **Velocidad de Lectura:** Acceso rápido a las reseñas de un producto.
* **Concurrencia de Escritura:** El sistema debe manejar muchas reseñas/comentarios simultáneos.
* **Flexibilidad:** El contenido textual (la reseña) puede variar en longitud y formato.

**Decisión:**
Base de Datos Documental (NoSQL, ej. MongoDB) para almacenar la entidad *Review*, y un campo pre-calculado en el Módulo CP para el promedio de valoración.

**Sustento:**
El modelo **Documental** es ideal para datos de texto **semiestructurados** y de alta **Concurrencia de Escritura**. Para optimizar la **Velocidad de Lectura**, el **Promedio de Valoración** se calculará asíncronamente y se enviará como metadato al Módulo CP para su visualización inmediata, evitando consultas lentas.

## 06: Módulo: Análisis de Datos y Reportes
---
### Decisión 1: Organización de Datos para Consultas Analíticas

**Título:**
Modelo de Almacenamiento y Organización para la Analítica de Datos

**Contexto:**
El Módulo ADR requiere realizar consultas complejas sobre grandes volúmenes de datos históricos (ventas, búsquedas, demografía) para generar reportes y métricas de tendencia, sin afectar los sistemas de producción.

**Alternativas:**

* **Almacenamiento en Base de Datos Relacional Normalizada:** Ineficiente y lento para consultas de agregación a través de grandes periodos de tiempo.
* **Modelo Dimensional (Data Warehouse):** Organización de datos optimizada para consultas (esquema estrella/copo de nieve), ideal para reportes **OLAP** y agregación.
* **Data Lake (Almacenamiento de Archivos Brutos):** Permite el almacenamiento de datos sin procesar, ideal para exploraciones de Machine Learning y análisis futuros.

**Criterios de Elección:**

* **Velocidad de Consulta Analítica:** Optimizar las consultas de agregación y filtros complejos.
* **Separación de Cargas:** Aislar totalmente la carga de la analítica de la carga transaccional.
* **Escalabilidad de Almacenamiento:** Manejar petabytes de datos históricos de forma rentable.

**Decisión:**
Combinación de **Data Warehouse (Modelo Dimensional)** para reportes estructurados y **Data Lake** para almacenamiento de eventos brutos (eventos de búsqueda, clics).

**Sustento:**
La utilización de un **Data Warehouse (Modelo Dimensional)** garantiza la **Velocidad de Consulta Analítica** para los reportes de ventas y tendencias estructuradas. El **Data Lake** proporciona **Escalabilidad** de almacenamiento y una fuente de datos *raw* para futuros proyectos de *Machine Learning* sobre el comportamiento de búsqueda y *churn* de usuarios.

---

[⬅️ Anterior](../4.7.2/4.7.2.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../4.7.4/4.7.4.md)