> [4. Decisiones Iniciales de Arquitectura](../../4.md) › [4.7. Listado Consolidado](../4.7.md) › [4.7.5. Elección de Tecnología](4.7.5.md)

# 4.7.5. Elección de Tecnología
---
Este apartado define las tecnologías específicas (lenguajes, *frameworks*, motores de bases de datos) seleccionadas para la implementación de los microservicios, basadas en los modelos de Datos, Coordinación y Recursos previamente definidos.

## 00: Decisiones Generales de Tecnología
---
### Decisión 1: Lenguaje de Programación para el *Backend*

##### Título:
Elección del Lenguaje de Desarrollo para Microservicios (Tipado Dinámico)

##### Contexto:
Se decidió previamente usar un lenguaje de **tipado dinámico** para priorizar la velocidad de desarrollo y minimizar el número de lenguajes. El equipo tiene experiencia con Javascript y Python. Los módulos críticos necesitan alta concurrencia y acceso rápido a E/S (*Input/Output*).

##### Alternativas:
* **Node.js (Javascript/Typescript):** Alto rendimiento en I/O asíncrono, mantiene un *stack* de lenguaje unificado (*frontend/backend*). Curva de aprendizaje baja para el equipo.
* **Python (Django/Flask):** Excelente para el procesamiento rápido de datos (ADR) y la lógica de negocio, pero la concurrencia nativa puede ser menos eficiente que Node.js en tareas de red.

##### Criterios de Elección:
* **Velocidad de Desarrollo:** Rapidez para el equipo pequeño.
* **Concurrencia:** Eficiencia para manejar miles de conexiones simultáneas.
* **Unificación del *Stack*:** Posibilidad de usar un lenguaje similar en *frontend* y *backend*.

##### Decisión:
**Node.js** utilizando **TypeScript** para el *backend* transaccional (GU, CCP, SP, LE, CR). **Python** para el módulo de Análisis de Datos y Reportes (ADR).

##### Sustento:

Node.js/TypeScript ofrece la **Concurrencia** y el rendimiento en I/O necesarios para las APIs de microservicios y permite la **Unificación del *Stack*** con el *frontend*. Se elige **TypeScript** sobre JavaScript plano para introducir la seguridad de tipos necesaria y mitigar los riesgos del tipado dinámico en los módulos financieros (SP). **Python** se reserva para ADR por su superioridad en bibliotecas de procesamiento y *Machine Learning*.

### Decisión 2: *Framework* de Desarrollo *Frontend*

##### Título:
Elección del *Framework* Principal para la Interfaz de Usuario

##### Contexto:
La interfaz de GameVault necesita ser rápida, reactiva y adaptable a múltiples dispositivos (móvil y web). Se busca un *framework* que tenga una gran comunidad y herramientas maduras.

##### Alternativas:
* **React:** Gran ecosistema, rendimiento optimizado con Virtual DOM, y excelente para aplicaciones grandes y modulares.
* **Angular:** *Framework* completo (*opinionated*), ideal para aplicaciones empresariales grandes y estables.
* **Vue.js:** Equilibrio entre React y Angular, muy fácil de aprender y rápido.

##### Criterios de Elección:
* **Velocidad de Desarrollo (UX):** Rapidez en la creación de componentes y experiencia de usuario.
* **Ecosistema y Comunidad:** Disponibilidad de bibliotecas y recursos de soporte.
* **Compatibilidad con TypeScript:** Integración nativa o madura con el lenguaje elegido para el *backend*.

##### Decisión:
**React** utilizando **TypeScript (TSX)** como *framework* principal.

##### Sustento:
**React** ofrece la mayor **Velocidad de Desarrollo** y el mejor **Ecosistema**, lo cual es crucial para un equipo pequeño que necesita agregar Funcionalidades Rápidas. Su adopción de **TypeScript** es madura, facilitando el desarrollo *Full-Stack* con Node.js.

## 01: Módulo: Catálogo de Productos
---
### Decisión 1: Motor de Base de Datos Principal (Datos de Producto)

##### Título:
Elección del Motor de BD para el Catálogo (Lectura/Escritura)

##### Contexto:
El Catálogo almacena información estructurada (precio, stock) y semi-estructurada (etiquetas, géneros, condición). Se requiere integridad transaccional para el inventario, pero alta flexibilidad para las propiedades variables de los juegos.

##### Alternativas:
* **MongoDB (NoSQL Documental):** Flexible, ideal para datos semi-estructurados, pero pobre en integridad transaccional y *joins* complejos.
* **PostgreSQL (Relacional):** Máxima integridad transaccional y excelente para inventario/stock, con buenas capacidades JSON nativas.

##### Criterios de Elección:
* **Integridad Transaccional:** Crítica para la gestión de inventario y *stock*.
* **Flexibilidad de Esquema:** Manejar la variedad de metadatos de los juegos.
* **Alto Rendimiento en Lectura:** Soporte para indexación y consultas rápidas.

##### Decisión:
**PostgreSQL** como base de datos principal, aprovechando sus características de integridad relacional para el inventario y las características de **JSONB** para los metadatos flexibles del producto.

##### Sustento:
**PostgreSQL** ofrece la **Integridad Transaccional** necesaria para el inventario (bloqueo pesimista, ver 4.6.4), superando la debilidad de MongoDB en este aspecto. Sus tipos **JSONB** satisfacen la **Flexibilidad de Esquema**.

### Decisión 2: Tecnología de *Caching*

##### Título:
Elección de Tecnología para *Caching* y Sesiones

##### Contexto:
Se decidió usar un *layer* de *caching* para aliviar la carga de lectura de la BD. Se necesita un almacenamiento de clave-valor ultrarrápido y distribuido.

##### Alternativas:
* **Redis:** Almacén clave-valor en memoria, ultrarrápido y flexible.
* **Memcached:** Alternativa simple y rápida, pero menos rica en estructuras de datos que Redis.

##### Criterios de Elección:
* **Baja Latencia:** Esencial para servir datos del catálogo rápidamente.
* **Estructuras de Datos:** Soporte para tipos complejos (listas, *hashes*, *sets*).
* **Capacidad Distribuida:** Funcionamiento eficiente en un entorno de microservicios.

##### Decisión:
**Redis** como motor de caché distribuido.

##### Sustento:
**Redis** es el estándar de la industria para *Caching* y persistencia de sesiones (en caso de que el API Gateway lo requiera). Su estructura de clave-valor en memoria garantiza la **Baja Latencia** necesaria para un catálogo.

## 02: Módulo: Gestión de Usuarios
---
### Decisión 1: Motor de Base de Datos para Usuarios y Seguridad

##### Título:
Elección del Motor de BD para Perfiles, Roles y Autenticación

##### Contexto:
Los datos de usuario (perfiles, roles, historial básico) son inherentemente relacionales (un usuario tiene un perfil, un rol, muchas transacciones). La seguridad es primordial.

##### Alternativas:
* **MySQL:** Motor relacional robusto y muy popular.
* **PostgreSQL:** Motor relacional con mejor soporte para características avanzadas (JSONB, GIS) y mejor considerado para transacciones complejas.

##### Criterios de Elección:
* **Integridad y Seguridad:** Fiabilidad en la gestión de credenciales y roles.
* **Familiaridad con la Plataforma:** Armonizar con las otras decisiones de BD.
* **Capacidad Transaccional:** Soporte para ACID completo.

##### Decisión:
**PostgreSQL** para la persistencia de usuarios, roles y seguridad.

##### Sustento:
Estandarizar **PostgreSQL** facilita la gestión de infraestructura y aprovecha su madurez en **Seguridad** y capacidad transaccional.

## 03: Módulo: Carrito de Compras y Pedidos
---
### Decisión 1: Motor de Base de Datos para Pedidos (Transaccional)

##### Título:
Elección del Motor de BD para Órdenes, Historial y Carrito de Compras

##### Contexto:
Los pedidos son el núcleo de la empresa. Requieren la máxima integridad transaccional y auditoría. El carrito de compras necesita un almacén rápido y volátil para el estado de la sesión.

##### Alternativas:
* **PostgreSQL:** Máxima integridad transaccional para pedidos.
* **Redis:** Almacén clave-valor para la gestión de carritos volátiles.
* **MySQL:** Alternativa relacional para pedidos, pero menos popular en el ecosistema Node.js/Typescript para alto rendimiento.

##### Criterios de Elección:
* **Integridad de Datos:** Máxima prioridad para el registro de órdenes.
* **Velocidad para Sesión:** Requerimiento de latencia mínima para el estado del carrito.
* **Soporte para Auditoría:** Capacidad de mantener un historial inmutable de cambios.

##### Decisión:
**PostgreSQL** para la persistencia de Órdenes e Historial de Pedidos. **Redis** para la gestión de Carritos de Compra (datos de sesión volátiles).

##### Sustento:
**PostgreSQL** asegura la **Integridad Transaccional** y la auditoría del historial de órdenes. **Redis** se utiliza para el Carrito (mecanismo volátil) para minimizar la carga de I/O en la BD principal del pedido y aprovechar la velocidad de caché.

## 04: Módulo: Sistema de Pagos
---
### Decisión 1: Tecnología de Pasarelas de Pago

##### Título:
Elección de Pasarelas de Pago Externas

##### Contexto:
Se requiere integración con pasarelas internacionales (**PayPal**) y locales (**Yape, Plin**) para maximizar la cobertura del mercado.

##### Alternativas:
* **PayPal:** Estándar internacional para transacciones seguras.
* **Stripe/Mercado Pago:** Alternativas internacionales populares.
* **Yape/Plin:** Billeteras digitales locales esenciales para el mercado objetivo.

##### Criterios de Elección:
* **Cobertura de Mercado:** Acceso a métodos de pago internacionales y locales.
* **Seguridad y Cumplimiento (PCI):** Delegación de la responsabilidad de manejo de datos sensibles.
* **Facilidad de Integración:** Disponibilidad de SDKs robustos.

##### Decisión:
Integración directa con el SDK/APIs de **PayPal** y APIs de servicios financieros locales (**Yape/Plin**).

##### Sustento:
Usar los SDKs oficiales reduce la complejidad de **Seguridad y Cumplimiento normativo (PCI *compliance*)** en el Módulo SP. La integración de billeteras locales es esencial para el contexto del mercado.

## 05: Módulo: Comunidad y Reseñas
---
### Decisión 1: Motor de Base de Datos para Reseñas y Contenido No Estructurado

##### Título:
Elección del Motor de BD para Contenido de Usuario (Reseñas, Comentarios)

##### Contexto:
Las reseñas y comentarios son texto libre y pueden variar en longitud y estructura. Las consultas se centran en buscar contenido por usuario o por producto, y en agregar nuevos comentarios.

##### Alternativas:
* **MongoDB:** Documental NoSQL, flexible y alto rendimiento en escritura.
* **PostgreSQL (JSONB):** Relacional, pero usaría solo el tipo JSONB para almacenar el documento.
* **Elasticsearch:** Ideal para búsqueda de texto completo, pero más complejo para tareas transaccionales.

##### Criterios de Elección:
* **Escalabilidad de Escritura:** Capacidad de manejar un alto volumen de nuevas reseñas.
* **Flexibilidad de Esquema:** Las reseñas pueden evolucionar (ej. añadir metadatos de usuario).
* **Soporte para Agregación:** Capacidad de calcular valoraciones promedio rápidamente.

##### Decisión:
**MongoDB (NoSQL Documental)** para la persistencia de Reseñas y Comentarios.

##### Sustento:
**MongoDB** es ideal para datos de **Contenido de Usuario** (documentos flexibles). Proporciona un **Alto Rendimiento en Escritura** de documentos, lo cual es ventajoso para una gran cantidad de reseñas que se añaden continuamente.

## 06: Módulo: Análisis de Datos y Reportes
---
### Decisión 1: Almacén de Datos Analíticos (*Data Warehouse*)

##### Título:
Elección del Almacén de Datos para Tareas OLAP (Analíticas)

##### Contexto:
ADR necesita una base de datos optimizada para consultas pesadas (*joins* complejos, agregaciones masivas) sobre grandes volúmenes de datos históricos (OLAP), que vienen de todos los microservicios.

##### Alternativas:
* **PostgreSQL:** Bueno para OLAP inicial, familiar para el equipo.
* **Snowflake/BigQuery:** Plataformas de *Data Warehouse Cloud*, mejor escalabilidad a costo más alto.
* **Apache Druid:** Base de datos distribuida optimizada para agregaciones en tiempo real.

##### Criterios de Elección:
* **Escalabilidad Analítica:** Capacidad para manejar consultas complejas y grandes.
* **Compatibilidad de Ingesta:** Capacidad de procesar datos de *Event Streams*.
* **Costo Operacional:** Mantener la complejidad y el gasto bajos en la etapa inicial.

##### Decisión:
**PostgreSQL** para un *Data Warehouse* inicial (por simplicidad y coste), y uso de **Apache Kafka** como la plataforma de *Event Streaming* central para alimentar este y futuros almacenes.

##### Sustento:
**PostgreSQL** es una solución sólida para iniciar el *Data Warehouse* y es familiar para el equipo. **Kafka** es esencial como *Broker* de Eventos de alto rendimiento, asegurando que todos los microservicios publiquen sus datos clave para la analítica de manera eficiente.

---

[⬅️ Anterior](../4.7.4/4.7.4.md) | [🏠 Home](../../../README.md)