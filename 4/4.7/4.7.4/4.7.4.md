> [4. Decisiones Iniciales de Arquitectura](../../4.md) › [4.7. Listado Consolidado](../4.7.md) › [4.7.4. Mapeo entre elementos de Arquitectura](4.7.4.md)

# 4.7.4. Gestión de Recursos

Este apartado se centra en la identificación de los recursos compartidos, el establecimiento de límites y las estrategias de arbitraje para gestionar la contención y prevenir la saturación o el colapso del sistema.

## 00: Decisiones Generales de Recursos
---
### Decisión 1: Estrategia de Protección Global y Anticascada

**Título:**
Estrategia de Protección Global de Tráfico

**Contexto:**
La API Gateway actúa como el punto único de entrada para todas las peticiones externas. Es la primera línea de defensa para aplicar políticas de protección contra la sobrecarga externa o fallos internos que puedan causar un efecto dominó (fallo en cascada) a los microservicios.

**Alternativas:**

* **Solo Rate Limiting:** Limitar solo la tasa de peticiones (RPS), sin verificar la salud del backend. No previene fallos internos.

* **Solo Circuit Breaker:** Abrir el circuito solo después de que el backend ya esté sufriendo o fallando. No previene la saturación inicial.

**Criterios de Elección:**

* **Resiliencia:** Prevenir el colapso por fallos en cascada.

* **Estabilidad:** Mantener una tasa de peticiones saludable para los backends.

* **Defensa:** Actuar como primer filtro de seguridad contra sobrecargas externas.

**Decisión:**
Implementación obligatoria de Circuit Breaker y Rate Limiting a nivel de API Gateway. El Rate Limiter se configurará con un Token Bucket Algorithm para suavizar los picos de tráfico.

**Sustento:**
El Rate Limiting previene la saturación por tráfico excesivo (externo), asegurando que los recursos downstream no se agoten inmediatamente. El Circuit Breaker monitorea la latencia y tasa de errores de los microservicios y detiene las llamadas a los servicios inestables, evitando el colapso por fallo en cascada, lo cual es crítico en una arquitectura de microservicios.

## 01: Módulo: Catálogo de Productos
---
### Decisión 1: Limitación de Conexiones a la Base de Datos

**Título:**
Estrategia de Pool de Conexiones para el Catálogo

**Contexto:**
El Catálogo es el módulo más consultado por los usuarios (lectura intensiva). Un exceso de consultas simultáneas podría agotar el *pool* de conexiones de PostgreSQL y colapsar el servicio.

**Alternativas:**

* **Pool Fijo Pequeño:** Limitar estrictamente el número de conexiones a 50. Seguro, pero podría generar latencia en picos de tráfico.
* **Pool Dinámico Grande:** Permitir hasta 200 conexiones, ajustando dinámicamente. Riesgoso para la base de datos subyacente.

**Criterios de Elección:**

* **Disponibilidad:** Mantener el servicio activo bajo alta carga de lectura.
* **Estabilidad del Motor de BD:** No saturar PostgreSQL.
* **Eficiencia de Latencia:** Minimizar el tiempo de espera de las consultas.

**Decisión:**
Se implementará un **pool de conexiones moderado (máximo 100)** en el *framework* del *backend* de CP, combinado con un *sidecar* de conexión (**Pgbouncer**) para multiplexar las conexiones.

**Sustento:**
El uso de **Pgbouncer** desacopla la aplicación de las conexiones físicas a PostgreSQL, permitiendo un *Pool Fijo* eficiente en el *backend* y el multiplexado, mejorando la **Disponibilidad** sin sobrecargar la BD.

### Decisión 2: Arbitraje de Acceso a Inventario 

**Título:**
Mecanismo de Arbitraje para Bloqueo de Inventario

**Contexto:**
La actualización del *stock* de inventario (cuando se hace un pedido) es una operación crítica que ocurre en CP y debe ser **atómica y aislada** para evitar la doble venta.

**Alternativas:**

* **Bloqueo Optimista:** Usar números de versión (*versioning*) en el registro de *stock*. Más rápido, pero puede fallar si hay alta contención (requiere reintento).
* **Bloqueo Pesimista:** Usar bloqueos a nivel de fila en la transacción de PostgreSQL. Más lento, pero garantiza la consistencia bajo alta contención.

**Criterios de Elección:**

* **Integridad del Stock:** No permitir la doble venta bajo ninguna circunstancia (máxima prioridad).
* **Escalabilidad de Escritura:** Minimizar el tiempo que dura el bloqueo.

**Decisión:**
Implementar **Bloqueo Pesimista** (**SELECT FOR UPDATE**) a nivel de fila dentro de la transacción del servicio que ajusta el inventario.

**Sustento:**
Aunque introduce una latencia mínima, el **Bloqueo Pesimista** garantiza la **Integridad del Stock** absoluta, que es un requisito de negocio no negociable para una plataforma de *e-commerce*.

## 02: Módulo: Gestión de Usuarios
---
### Decisión 1: Límite de Tasa (Rate Limiting) en Endpoints de Autenticación

**Título:**
Gestión de Recursos en Intentos de Login/Registro

**Contexto:**
Los *endpoints* de *login* y registro son vulnerables a ataques de fuerza bruta o de denegación de servicio (**DoS**) si no se limita el consumo de recursos.

**Alternativas:**

* **Rate Limit por IP:** Bloqueo basado únicamente en la dirección IP. Fácil de evadir con *proxies*.
* **Rate Limit por Usuario/Email:** Bloqueo basado en la combinación de IP y la cuenta intentada.

**Criterios de Elección:**

* **Seguridad:** Prevenir ataques de fuerza bruta.
* **Experiencia de Usuario:** No bloquear a usuarios legítimos detrás de una IP compartida.

**Decisión:**
Implementar **Rate Limiting por Usuario/Email** con un límite de 5 intentos fallidos en 5 minutos, y un límite secundario más suave por IP.

**Sustento:**
Combinar ambos límites maximiza la **Seguridad** al prevenir ataques dirigidos a cuentas específicas, mientras que el límite secundario por IP previene el abuso de recursos desde una única fuente, mejorando la **Experiencia de Usuario** frente a redes compartidas.

## **03: Módulo: Carrito de Compras y Pedidos**
---
### **Decisión 1: Tiempo de Vida (TTL) de los Carritos de Compra**

**Título:**
Gestión de Recursos en Memoria para Datos de Carrito

**Contexto:**
Los carritos de compra se almacenan en Redis para un acceso rápido. Si no se gestionan, los carritos inactivos (abandonados) consumen recursos valiosos en memoria de forma indefinida. Es necesario definir una política para liberar este espacio de manera eficiente y automática.

**Alternativas:**

* **Sin Expiración:** Los carritos permanecen en memoria hasta que el usuario los vacía o completa la compra. (Alto consumo de memoria, insostenible a largo plazo).
* **Expiración Fija (TTL):** Se asigna un Tiempo de Vida (Time-To-Live) a cada carrito. Redis elimina automáticamente la clave cuando el tiempo expira.

**Criterios de Elección:**

* **Optimización de Memoria:** Es un aspecto clave de la **Gestión de Recursos**. Liberar memoria de carritos abandonados asegura que el rendimiento de Redis no se degrade para los usuarios activos.
* **Experiencia de Usuario (UX):** Un TTL demasiado corto puede frustrar al usuario si vuelve para completar su compra y encuentra el carrito vacío. El tiempo debe ser razonable para no afectar negativamente la **Usabilidad**.
* **Simplicidad de Implementación:** La solución debe ser fácil de implementar y mantener. La funcionalidad de TTL nativa de Redis es una solución simple y robusta.

**Decisión:**
Expiración Fija (TTL).

**Sustento:**
Un **TTL de 48 horas** representa un equilibrio óptimo entre la **Optimización de Memoria** y una buena **Experiencia de Usuario**. Este plazo permite que los usuarios regresen al día siguiente para finalizar su compra sin perder su selección, mientras se garantiza una purga automática y eficiente de los datos abandonados.

***

## **04: Módulo: Sistema de Pagos**
---
### **Decisión 1: Gestión de Recursos para Reintentos de Pago**

**Título:**
Estrategia de Reintentos con Backoff Exponencial para Llamadas a Pasarelas de Pago

**Contexto:**
Las llamadas síncronas a la pasarela de pago externa (Stripe) pueden fallar por problemas transitorios de red o saturación del servicio. Se necesita una estrategia de reintentos que sea resiliente y no agrave el problema de saturación.

**Alternativas:**

* **Reintentos Inmediatos:** Reintentar la llamada inmediatamente después de un fallo. (Riesgo de colapsar la pasarela si el problema es persistente, consumiendo recursos innecesariamente).
* **Backoff Exponencial:** Aumentar el tiempo de espera exponencialmente entre reintentos, dando tiempo al servicio externo para recuperarse.

**Criterios de Elección:**

* **Disponibilidad de la Transacción:** La estrategia debe maximizar la probabilidad de que un pago se complete si el fallo es temporal. Esta es una táctica clave para la **Disponibilidad**.
* **Uso Eficiente de Recursos:** Se debe evitar el consumo excesivo de hilos o procesos en el SP mientras se espera, y al mismo tiempo, no sobrecargar al proveedor externo con peticiones repetitivas.
* **Resiliencia:** El sistema debe ser capaz de manejar fallos transitorios de forma controlada sin que la transacción falle por completo de inmediato.

**Decisión:**
Backoff Exponencial.

**Sustento:**
El **Backoff Exponencial** es una práctica estándar que mejora la **Disponibilidad** al manejar fallos transitorios de manera inteligente. Aumenta las posibilidades de éxito de la transacción sin sobrecargar los **recursos del sistema externo**, lo que demuestra un diseño robusto y resiliente.

## 05: Módulo: Comunidad y Reseñas
---
### Decisión 1: Limitación de Recursos de Almacenamiento (Tamaño Máximo de Reseña)

**Título:**
Límite Máximo de Tamaño de Documento de Reseña

**Contexto:**
El módulo CR almacena reseñas en MongoDB. Se debe prevenir que usuarios maliciosos inserten documentos gigantescos que degraden el rendimiento de las consultas e incrementen el consumo de almacenamiento innecesario.

**Alternativas:**

* **Límite Alto (1MB):** Usar el límite de MongoDB. Demasiado grande para texto simple.
* **Límite Estricto (5KB):** Establecer un límite basado en el uso real de una reseña.

**Criterios de Elección:**

* **Seguridad y Costo:** Prevenir el abuso y controlar el tamaño de la BD.
* **Experiencia de Usuario:** Permitir suficiente espacio para reseñas detalladas.

**Decisión:**
Imponer un **límite de 10,000 caracteres** (aproximadamente 20KB de almacenamiento de documento) en el campo de texto de la reseña, validado en el servicio de *backend*.

**Sustento:**
Este límite proporciona suficiente espacio para reseñas muy detalladas (**Experiencia de Usuario**) mientras que previene eficazmente la sobrecarga de **Seguridad y Costo** que podría generar un documento de 1MB.

## 06: Módulo: Análisis de Datos y Reportes
---
### Decisión 1: Limitación de Consultas Analíticas (Concurrencia)

**Título:**
Arbitraje de Consultas Pesadas en el Data Warehouse

**Contexto:**
Las consultas de reporte (**OLAP**) son inherentemente lentas y consumen muchos recursos de CPU/RAM de PostgreSQL. Demasiadas consultas simultáneas colapsarán el *Data Warehouse* y afectarán la generación de reportes.

**Alternativas:**

* **Cola de Consultas:** Poner las consultas en una cola y ejecutarlas secuencialmente. Seguro, pero puede generar latencia inaceptable.
* **Límite de Concurrencia:** Permitir un número fijo y bajo de consultas simultáneas.

**Criterios de Elección:**

* **Estabilidad del Reporte:** Priorizar la finalización de los reportes sobre la velocidad.
* **Uso Eficiente de Recursos:** No permitir la saturación de CPU/RAM.

**Decisión:**
Limitar el *pool* de conexiones del módulo ADR a PostgreSQL a un **máximo de 10 conexiones concurrentes** y usar tiempos de espera (*timeouts*) estrictos (máx. 60 segundos).

**Sustento:**
Limitar la **Concurrencia** es la forma más efectiva de garantizar la **Estabilidad del Reporte** al evitar que múltiples consultas pesadas compitan por los mismos recursos de CPU y disco, asegurando que el sistema no colapse bajo carga analítica.

---

[⬅️ Anterior](../4.7.3/4.7.3.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../4.7.5/4.7.5.md)