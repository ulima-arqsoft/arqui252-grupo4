# 2.3. Restricciones
- [Volver al índice](/2/3.md)

Las restricciones del sistema GameVault se presentan tanto a nivel general como específico por módulo, basadas en las decisiones arquitectónicas tomadas y las limitaciones técnicas y de negocio identificadas.

## Restricciones Generales del Sistema

- **Arquitectura de Microservicios**: La solución debe implementarse bajo una **arquitectura de microservicios**. Esto restringe el desarrollo de un monolito y obliga a que cada funcionalidad principal (módulos) sea un servicio independiente.
- **Tecnología de Desarrollo**: El **backend** debe ser desarrollado en **Node.js** utilizando el framework **Express.js**, mientras que el **frontend** debe construirse exclusivamente con **React**. Esto estandariza la pila tecnológica y limita el uso de otros lenguajes o frameworks.
- **Gestión de Bases de Datos**: Se debe utilizar un modelo de datos híbrido: **Postgresql** para datos relacionales críticos (usuarios, transacciones de pago) y **MongoDB** para datos no relacionales (reseñas, registros de foros). Esto restringe el uso de un solo tipo de base de datos.
- **Despliegue y Orquestación**: El despliegue del sistema debe realizarse en **contenedores Docker** y su orquestación debe ser gestionada con **Kubernetes**. Esto limita el uso de otros orquestadores como Docker Swarm.
- **Entorno de Operación**: La plataforma debe ser **exclusivamente web**, sin desarrollo de aplicaciones nativas para iOS o Android.

## Restricciones por Módulo

### Módulo: Gestión de Usuarios

- **Tecnología de Autenticación**: Este módulo debe implementar su propio sistema de autenticación utilizando **JSON Web Tokens (JWT)**. Esto restringe el uso de servicios externos como Google Auth o Firebase Auth.
- **Almacenamiento de Datos**: La información de usuarios, roles y permisos debe almacenarse exclusivamente en **Postgresql** para asegurar la integridad y la consistencia de los datos.
- **Roles de Usuario**: El sistema debe soportar un mínimo de tres roles de usuario: **administrador, vendedor y comprador**. La implementación debe asegurar que los permisos de cada rol estén claramente definidos.

### Módulo: Catálogo de Productos

- **API Externa**: La información de productos debe ser obtenida de la **LastFM API**. No se permite el uso de otras APIs externas para el catálogo principal de música.
- **Optimización de Búsqueda**: El motor de búsqueda debe usar **Elasticsearch** para proporcionar resultados de búsqueda en tiempo real, lo que restringe el uso de consultas directas a la base de datos relacional para la funcionalidad de búsqueda.
- **Manejo de Imágenes**: Las imágenes de los álbumes y artistas deben ser optimizadas y almacenadas en un servicio de almacenamiento de objetos, como **Amazon S3** o similar, para una carga rápida.

### Módulo: Análisis de Datos y Reportes

- **Tecnología**: El módulo de Análisis de Datos y Reportes debe hacer uso del lenguaje **Python** para el desarrollo de los modelos de datos y la generación de métricas y reportes. Esto restringe el uso de otros lenguajes.
- **Librerías**: Se utilizarán exclusivamente las librerías **Pandas** y **NumPy** para el análisis de datos, lo que restringe el uso de otras.
- **Almacenamiento**: Los datos para los reportes deben ser extraídos de un **Data Lake** independiente para evitar afectar el rendimiento de la base de datos principal, restringiendo la consulta directa a la base de datos de producción.

### Módulo: Sistema de Pagos

- **Pasarela de Pagos**: El módulo de pagos debe integrarse exclusivamente con la pasarela **Stripe**. No se considerarán otras opciones como PayPal o Mercado Pago.
- **Seguridad de Transacciones**: Las transacciones deben cumplir con el estándar **PCI-DSS**. La arquitectura debe garantizar que los datos de las tarjetas de crédito nunca sean almacenados en los servidores de la aplicación.
- **Notificaciones**: Las notificaciones de transacciones exitosas o fallidas deben ser gestionadas a través de **webhooks** de Stripe para garantizar su fiabilidad, lo que prohíbe el uso de polling periódico.

### Módulo: Logística y Envíos

- **Comunicación con Proveedores**: La comunicación con los proveedores de envío debe realizarse a través de una **API de adaptador** para permitir la futura integración de nuevos proveedores sin cambios en la lógica del negocio.
- **Actualizaciones de Estado**: El sistema debe utilizar un **sistema de colas de mensajes** para manejar las actualizaciones de estado de los envíos de manera asíncrona, lo que restringe el uso de llamadas síncronas.
- **Entorno de Pruebas**: Las pruebas con proveedores se realizarán en un **entorno de sandbox** para evitar transacciones reales, restringiendo el uso de credenciales de producción para pruebas.

### Módulo: Carrito de Compras y Pedidos

- **Tipo de Base de Datos**: Los datos del carrito de compras deben almacenarse en **Redis** debido a la necesidad de acceso rápido a datos efímeros, lo que restringe su almacenamiento en bases de datos relacionales o documentales.
- **Persistencia**: La información de los pedidos completados se migrará a la base de datos **Postgresql** para su almacenamiento permanente.
- **Comunicación**: La comunicación con el módulo de pagos debe ser **síncrona** para garantizar que el pago se confirme antes de crear el pedido, restringiendo la creación de pedidos basados en eventos asíncronos de pago.

### Módulo: Comunidad y Reseñas

- **Tipo de Base de Datos**: Las reseñas de los usuarios deben almacenarse en la base de datos **MongoDB**, dado su formato flexible y no estructurado. Esto restringe su almacenamiento en Postgresql.
- **Moderación de Contenido**: Debe implementarse un sistema de **moderación de contenido** para revisar y aprobar las reseñas de los usuarios antes de su publicación. Esto restringe la publicación automática de reseñas.
- **Carga de Datos**: Las reseñas deben ser cargadas de forma asíncrona mediante un **lazy loading** para no afectar el rendimiento de la página principal del producto, restringiendo la carga de todas las reseñas de una vez.