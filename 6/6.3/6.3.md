> [6. Documentaci√≥n de Arquitectura](../6.md) ‚Ä∫ [6.3. Diagrama de Componentes](6.3.md)

## 6.3. Diagrama de Componentes



El **Diagrama de Componentes** detalla la estructura interna de los principales contenedores (microservicios) definidos en la arquitectura de GameVault. Especifica los m√≥dulos l√≥gicos clave, servicios, repositorios y adaptadores que colaboran dentro de cada microservicio. Este nivel describe c√≥mo se organizan estos componentes y c√≥mo interact√∫an entre s√≠ o con sistemas externos (bases de datos, APIs, Kafka).



---

## Descripci√≥n General



Cada microservicio encapsula sus propias responsabilidades, datos y l√≥gica, siguiendo los principios de **alta cohesi√≥n** y **bajo acoplamiento**. Los componentes internos se organizan t√≠picamente en capas funcionales:



| Tipo de Componente | Descripci√≥n                                   |

| :------------------- | :------------------------------------------------------------------------------- |

| **Controller** | Gestiona las solicitudes entrantes (HTTP/Eventos) y delega a los servicios.     |

| **Service** | Implementa la l√≥gica de negocio principal y coordina las operaciones.       |

| **Repository** | Abstrae el acceso y la persistencia de datos en la base de datos del microservicio. |

| **Adapter/Client** | Encapsula la comunicaci√≥n con otros microservicios o sistemas externos (APIs).  |

| **Publisher/Consumer** | Gestiona la publicaci√≥n o consumo de eventos hacia/desde Kafka.         |



---

## Componentes Principales por Microservicio



### Cat√°logo de Productos (CP)



* **ProductController:** Expone endpoints REST para b√∫squeda, filtrado y detalle de productos.

* **ProductService:** Contiene la l√≥gica de negocio del cat√°logo, incluyendo la consulta a IGDB y la gesti√≥n del stock (puede interactuar con CCP o un m√≥dulo de inventario futuro).

* **ProductRepository:** Gestiona el acceso a la base de datos **PostgreSQL** para los datos maestros de productos.

* **SearchAdapter:** Interact√∫a con **Elasticsearch** para indexar y realizar b√∫squedas de texto completo.

* **IGDBAdapter:** Cliente HTTP para obtener metadatos de videojuegos desde la **IGDB API**.

* **EventPublisher:** Publica eventos (ej. `ProductoActualizado`) en **Kafka**.



### Gesti√≥n de Usuarios (GU)



* **UserController:** Expone endpoints REST para obtener/actualizar perfiles de usuario espec√≠ficos de GameVault.

* **UserService:** Implementa la l√≥gica de negocio relacionada con los perfiles (preferencias, historial, etc.). Interact√∫a con Auth0 para obtener datos del usuario si es necesario.

* **UserRepository:** Gestiona el acceso a la base de datos **PostgreSQL** para los perfiles.

* *(Nota: La l√≥gica de autenticaci√≥n (login, registro, JWT) es manejada externamente por **Auth0** y validada en el **API Gateway**).*



### Carrito y Pedidos (CCP)



* **CartController:** Expone endpoints REST para gestionar el carrito de compras.

* **OrderController:** Expone endpoints REST para crear y consultar pedidos.

* **CartService:** Implementa la l√≥gica de negocio para a√±adir/quitar √≠tems del carrito.

* **OrderService:** Orquesta el proceso de *checkout*, calcula precios, valida stock (interactuando con CP si es necesario), llama al Servicio de Pagos (SP) s√≠ncronamente y finalmente confirma el pedido.

* **CartRepository:** Gestiona el acceso a **Redis** para los datos vol√°tiles del carrito.

* **OrderRepository:** Gestiona el acceso a **PostgreSQL** para la persistencia de los pedidos.

* **PaymentAdapter:** Cliente HTTP para realizar la llamada s√≠ncrona al Servicio de Pagos (SP).

* **LogisticsAdapter:** Cliente HTTP para enviar datos del pedido confirmado a la API de Log√≠stica externa.

* **EventPublisher:** Publica eventos (ej. `PedidoCreado`) en **Kafka**.



### Sistema de Pagos (SP)



* **PaymentController:** Expone el endpoint REST que recibe la solicitud de pago s√≠ncrona desde CCP.

* **WebhookController:** Expone el endpoint REST que recibe las notificaciones as√≠ncronas (webhooks) desde **Culqi**.

* **PaymentService:** Implementa la l√≥gica de negocio principal: iniciar el pago con Culqi, procesar la confirmaci√≥n del webhook, y manejar posibles fraudes.

* **TransactionRepository:** Gestiona el acceso a la base de datos **PostgreSQL** para guardar el log inmutable de transacciones.

* **CulqiAdapter:** Encapsula toda la comunicaci√≥n (inicio de pago, validaci√≥n de webhooks) con la **API de Culqi**.

* **FraudValidator:** Componente interno (o servicio externo) que aplica reglas antifraude.

* **EventPublisher:** Publica eventos (ej. `PagoConfirmado`, `PagoFallido`) en **Kafka**.



### Comunidad y Rese√±as (CR)



* **ReviewController:** Expone endpoints REST para crear, leer y gestionar rese√±as y comentarios.

* **ReviewService:** Implementa la l√≥gica de negocio, incluyendo la llamada al servicio de moderaci√≥n.

* **ModerationService:** Componente (o servicio externo) que aplica reglas de moderaci√≥n al contenido de las rese√±as.

* **ReviewRepository:** Gestiona el acceso a la base de datos **MongoDB**.

* **EventPublisher:** Publica eventos (ej. `Rese√±aCreada`, `ValoracionActualizada`) en **Kafka**.



### An√°lisis de Datos y Reportes (ADR)



* **AnalyticsConsumer:** Componente (escrito en Python) que se suscribe y consume eventos desde **Kafka**.

* **AggregationService:** Utiliza librer√≠as como **Pandas/NumPy** para procesar, transformar y agregar los datos de los eventos.

* **DataLakeWriter:** Componente que escribe los datos procesados o brutos en el **Data Lake**.

* **(Opcional) ReportAPI:** Podr√≠a exponer endpoints REST (con Flask/FastAPI) para servir reportes precalculados desde un Data Warehouse si fuera necesario.



---

## Diagrama de Componentes



*(Aqu√≠ deber√≠as insertar la imagen del diagrama de componentes actualizado que refleja esta estructura, idealmente generado con PlantUML).*



![Diagrama de Contenedores](../Views/Componentes_GameVault.png)



---

## Conclusi√≥n



Este nivel de detalle permite comprender la responsabilidad funcional de cada componente dentro de los microservicios de GameVault. Se muestra claramente la separaci√≥n de responsabilidades (Controller, Service, Repository, Adapter), el uso de las tecnolog√≠as espec√≠ficas (PostgreSQL, Redis, MongoDB, Elasticsearch, Kafka, Culqi, Auth0) y las interacciones clave. Esta estructura modular facilita la **escalabilidad**, el **mantenimiento** y la evoluci√≥n independiente de cada parte del sistema.

‚¨ÖÔ∏è Anterior
 | üè† Home
 | Siguiente ‚û°Ô∏è
