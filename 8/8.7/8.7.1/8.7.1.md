> [8. Aplicaci√≥n de Patrones Arquitecturales](../../8.md) ‚Ä∫ [8.7. Listado Consolidado](../8.7.md) ‚Ä∫ [8.7.1. Patrones de M√≥dulo](8.7.1.md)

# 8.7.1. Patrones de M√≥dulo

## **01: M√≥dulo: Carrito de Compras y Pedidos**

---

**T√≠tulo:**
Organizaci√≥n modular interna del `Servicio de Cat√°logo (CP)` (Patr√≥n en Capas)

**Contexto:**
El `Servicio de Cat√°logo` es el microservicio m√°s consultado del sistema. Debe exponer una API REST para b√∫squedas, gestionar la l√≥gica de negocio (inventario, precios), interactuar con dos bases de datos distintas (PostgreSQL y Elasticsearch) y consumir datos de una API externa (IGDB). Se requiere una estructura interna que desacople estas responsabilidades para facilitar la mantenibilidad y la evoluci√≥n tecnol√≥gica.

**Alternativas:**

* **Patr√≥n de Arquitectura en Capas (Layered Architecture):**
    * Organizaci√≥n horizontal: `Controllers` (API), `Services` (Negocio), `Repositories` (Datos), `Adapters` (IGDB/Elastic).
    * Facilita la separaci√≥n de intereses: el controlador no sabe si el dato viene de la BD o de la API externa.
    * Alineado con las t√°cticas de mantenibilidad `ESC-CP 7` y `ESC-CP 10`.

* **Patr√≥n de "Gran Bola de Lodo" (Big Ball of Mud / Ad-Hoc):**
    * L√≥gica mezclada en funciones grandes.
    * Alto rendimiento inicial de desarrollo, pero deuda t√©cnica inmediata.
    * Dificulta la implementaci√≥n de la persistencia pol√≠glota (Postgres + Elastic).

**Criterios de elecci√≥n:**

* **Abstracci√≥n de Dependencias:** Necesidad de ocultar la complejidad de usar dos bases de datos (`ESC-CP 10`).
* **Cohesi√≥n:** Agrupar la l√≥gica de validaci√≥n y negocio separada de la infraestructura.
* **Estandarizaci√≥n:** Mantener coherencia con los otros microservicios Node.js (M√≥dulos 2, 3, 4).

**Decisi√≥n:**
Se adopta el **Patr√≥n de Arquitectura en Capas** para la estructura interna del `Servicio de Cat√°logo`.

**Sustento:**
Este patr√≥n estructura el c√≥digo tal como se defini√≥ en el **Diagrama de Componentes (C4 Nivel 3)**. Permite aislar la l√≥gica de b√∫squeda (que va a `Elasticsearch`) y la l√≥gica maestra (que va a `PostgreSQL`) dentro de la capa de repositorios/adaptadores, dejando la capa de servicio (`ProductService`) limpia para orquestar el negocio.


## **03: M√≥dulo: Carrito de Compras y Pedidos**

---

**T√≠tulo:**
Organizaci√≥n modular interna del `Servicio de Carrito y Pedidos (CCP)` (Patr√≥n en Capas)

**Contexto:**
El `Servicio de Carrito y Pedidos` (M√≥dulo 3) es un microservicio que debe manejar la l√≥gica de negocio (calcular totales, validar stock), la l√≥gica de API (recibir peticiones HTTP) y la l√≥gica de persistencia (escribir en Redis y PostgreSQL). Se requiere una estructura de c√≥digo interna que separe estas responsabilidades para que el servicio sea mantenible y testeable.

**Alternativas:**

* **Patr√≥n de Arquitectura en Capas (Layered Architecture):**
    * Organizaci√≥n horizontal por capas t√©cnicas: `Controllers`, `Services`, `Repositories`.
    * Facilita la separaci√≥n de responsabilidades: la l√≥gica de HTTP (Controller) est√° separada de la l√≥gica de negocio (Service) y de la l√≥gica de BD (Repository).
    * Permite la abstracci√≥n de dependencias y facilita las pruebas.

* **Estructura Ad-hoc (Sin Patr√≥n):**
    * Implementar toda la l√≥gica (API, negocio, BD) del carrito y los pedidos en un solo archivo `index.ts`.
    * Dificulta la evoluci√≥n (ej. cambiar de Redis a otra BD).
    * Genera alto acoplamiento y baja cohesi√≥n.

**Criterios de elecci√≥n:**

* **Mantenibilidad:** Facilidad para modificar la l√≥gica de c√°lculo de totales sin afectar el endpoint de la API.
* **Testabilidad:** Capacidad de probar la l√≥gica de `OrderService` (M√≥dulo 3) "mockeando" (simulando) el `PaymentAdapter` y el `OrderRepository`.
* **Cohesi√≥n:** Agrupar l√≥gicamente las responsabilidades (`RF-01` a `RF-06` del M√≥dulo 3).

**Decisi√≥n:**
Se adopta el **Patr√≥n de Arquitectura en Capas** para la estructura interna del `Servicio de Carrito y Pedidos (CCP)`.

**Sustento:**
La arquitectura en capas es la implementaci√≥n directa de nuestro **Diagrama de Componentes (C4 Nivel 3)**. Permite que el `CCP` tenga una estructura limpia que separa `CartController`/`OrderController` (la API), `CartService`/`OrderService` (el negocio) y `CartRepository`/`OrderRepository` (los datos). Esto es crucial para manejar la complejidad de este m√≥dulo, que escribe en dos BD distintas (`Redis` y `PostgreSQL`) y orquesta una llamada a otro servicio (`SP`).

## **04: M√≥dulo: Sistema de Pagos**

---

**T√≠tulo:**
Organizaci√≥n modular interna del Servicio de Pagos (SP) (Patr√≥n en Capas)

**Contexto:**
El Servicio de Pagos (M√≥dulo 4) es un microservicio de alta criticidad. Debe manejar la l√≥gica para conectarse a Culqi, la l√≥gica de negocio para validar pagos, la l√≥gica de API para recibir llamadas del CCP y los webhooks de Culqi, y la l√≥gica de persistencia para guardar transacciones en PostgreSQL. Se necesita una estructura de c√≥digo interna que separe estas responsabilidades.

**Alternativas:**

* **Patr√≥n de Arquitectura en Capas (Layered Architecture):**
    * Organizaci√≥n horizontal por capas t√©cnicas: Controllers, Services, Repositories.
    * Facilita la separaci√≥n de responsabilidades: la l√≥gica de Webhook (Controller) est√° separada de la l√≥gica de negocio (Service) y de la l√≥gica de BD (Repository).
    * Permite la encapsulaci√≥n de la API de Culqi en un Adapter.

* **Estructura Ad-hoc (Sin Patr√≥n):**
    * Mezclar la l√≥gica del webhook de Culqi directamente con la escritura en la base de datos en un solo archivo.
    * Dificulta la evoluci√≥n (ej. a√±adir otro proveedor de pago como Stripe).
    * Dificulta las pruebas y la mantenibilidad.

**Criterios de elecci√≥n:**

* **Mantenibilidad:** Facilidad para modificar la l√≥gica de conexi√≥n a Culqi sin afectar el resto del servicio (T√°ctica ESC-SP-03: Encapsulamiento).
* **Testabilidad:** Capacidad de probar la l√≥gica de PaymentService "mockeando" (simulando) el CulqiAdapter.
* **Cohesi√≥n:** Agrupar l√≥gicamente las responsabilidades (RF-01 a RF-06 del M√≥dulo 4).

**Decisi√≥n:**
Se adopta el Patr√≥n de Arquitectura en Capas para la estructura interna del Servicio de Pagos (SP).

**Sustento:**
La arquitectura en capas es la implementaci√≥n directa de nuestro Diagrama de Componentes (C4 Nivel 3). Permite que el SP implemente la t√°ctica ESC-SP-03 (Encapsulamiento) al aislar la l√≥gica de Culqi en un CulqiAdapter. El PaymentService contiene la l√≥gica de negocio, y el TransactionRepository maneja la persistencia en PostgreSQL. Esta separaci√≥n es crucial para un m√≥dulo de alta seguridad.

---

## **05: M√≥dulo: Comunidad y Rese√±as**

---

**T√≠tulo:**
Organizaci√≥n modular interna del `Servicio de Comunidad y Rese√±as (SCR)` (Patr√≥n en Capas)

**Contexto:**
El `Servicio de Comunidad y Rese√±as` (M√≥dulo 04) es un microservicio que debe gestionar la l√≥gica de API (recibir `POST` de nuevas rese√±as, `GET` para listarlas), la l√≥gica de negocio (validar compras, moderar contenido, calcular promedios) y la persistencia. Se requiere una estructura interna que separe estas responsabilidades para que el servicio sea mantenible y f√°cil de testear.

**Alternativas:**

* **Patr√≥n de Arquitectura en Capas (Layered Architecture):**
    * Organizaci√≥n horizontal jer√°rquica: `Controllers` (Presentaci√≥n) -> `Services` (Negocio) -> `Repositories` (Datos).
    * El flujo de dependencia es unidireccional (de arriba hacia abajo).
    * Es el est√°ndar de la industria para aplicaciones con l√≥gica de negocio de complejidad media.

* **Arquitectura Hexagonal (Ports and Adapters):**
    * A√≠sla completamente la l√≥gica de negocio (el "n√∫cleo") del mundo exterior mediante `Puertos` y `Adaptadores`.
    * La base de datos y la API son tratadas como detalles externos intercambiables.
    * Ofrece desacoplamiento m√°ximo, pero introduce mayor complejidad en la estructura y m√°s clases (boilerplate) para conectar las piezas.

* **Estructura Ad-hoc (Sin Patr√≥n):**
    * Implementar toda la l√≥gica (API, validaci√≥n de spam, escritura en BD) en un solo archivo o clase `ReviewHandler` sin una separaci√≥n formal de responsabilidades.
    * Genera alto acoplamiento, dificultando las pruebas y la reutilizaci√≥n.
    * Es la opci√≥n m√°s r√°pida para prototipos, pero insostenible a largo plazo.

**Criterios de elecci√≥n:**

* **Mantenibilidad:** Facilidad para modificar reglas de negocio sin que los cambios en la base de datos afecten al dominio, y viceversa.
* **Testabilidad:** Capacidad de probar la l√≥gica de `ReviewService` "mockeando" los repositorios.
* **Equilibrio Complejidad/Beneficio:** Evitar la sobreingenier√≠a (over-engineering), complejidad innecesariamente alta, y la subingenier√≠a (under-engineering), generando sobresimplificaci√≥n.

**Decisi√≥n:**
Se adopta el **Patr√≥n de Arquitectura en Capas** para la estructura interna del `Servicio de Comunidad y Rese√±as (SCR)`.

**Sustento:**
Se elige el **Patr√≥n en Capas** por ser el mejor punto medio entre las alternativas. La **Estructura Ad-hoc** se descarta por no ser profesional ni mantenible. La **Arquitectura Hexagonal**, aunque poderosa, introduce una complejidad innecesaria  para la l√≥gica de negocio de este m√≥dulo, que es relativamente directa. El Patr√≥n en Capas ofrece la estructura suficiente para separar `ReviewController` (API), `ReviewService` (Negocio) y `ReviewRepository` (Datos), cumpliendo con los criterios de mantenibilidad y testabilidad sin la sobrecarga de la arquitectura hexagonal.


## 06: M√≥dulo: An√°lisis de Datos y Reportes

---

**T√≠tulo:**
Organizaci√≥n interna del `Servicio de An√°lisis (ADR)` (Patr√≥n en Capas de Datos)

**Contexto:**
El M√≥dulo 6 es un servicio de procesamiento de datos que ingiere eventos, los transforma y los guarda. Aunque su comportamiento en tiempo de ejecuci√≥n es un "flujo", necesitamos organizar su c√≥digo fuente de manera que separe las responsabilidades t√©cnicas (conectarse a Kafka, l√≥gica matem√°tica con Pandas, escritura en Data Lake) para facilitar el mantenimiento y las pruebas unitarias.

**Alternativas:**

  * **Patr√≥n de Arquitectura en Capas (Layered Architecture):**

      * Organizaci√≥n horizontal del c√≥digo en capas l√≥gicas.
      * Adaptaci√≥n para Datos: `Capa de Ingesta` (Listener), `Capa de Procesamiento` (Business/Pandas), `Capa de Persistencia` (Writer).
      * **Ventaja:** Desacopla la fuente de datos de la l√≥gica de an√°lisis. Si cambiamos Kafka por RabbitMQ, solo tocamos la capa de Ingesta.
      * **Ventaja:** Facilita probar la l√≥gica matem√°tica (Procesamiento) de forma aislada.

  * **Estructura de Script Monol√≠tico (Sin Patr√≥n):**

      * Escribir un solo script lineal (ej. `main.py`) que lea de Kafka, calcule y guarde.
      * **Desventaja:** Dif√≠cil de testear y mantener. Mezcla infraestructura con reglas de negocio.

**Criterios de elecci√≥n:**

  * **Separaci√≥n de Responsabilidades:** Aislar la complejidad de la infraestructura (`Kafka`) de la l√≥gica de negocio (`Pandas`).
  * **Mantenibilidad:** Estructura clara para un equipo de desarrollo.
  * **Testabilidad:** Capacidad de hacer unit testing de los algoritmos de agregaci√≥n sin conectar a Kafka real.

**Decisi√≥n:**
Se adopta el **Patr√≥n de Arquitectura en Capas** adaptado para procesamiento de datos.

**Sustento:**
Aunque el flujo de datos es secuencial, la organizaci√≥n del c√≥digo debe ser en capas para cumplir con los criterios de mantenibilidad. Se definen tres capas estrictas:

1.  **Capa de Ingesta (Presentation/Input):** Maneja la conexi√≥n con `Kafka`.
2.  **Capa de Procesamiento (Domain/Business):** Contiene la l√≥gica pura de transformaci√≥n con `Pandas/NumPy`.
3.  **Capa de Persistencia (Data Access):** Maneja la escritura en el `Data Warehouse`.

---

[üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../8.7.2/8.7.2.md)
